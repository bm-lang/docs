== Principles

The design of the Bm Language is driven by a set of principles explained below.


=== Trackable Origin

Every symbol in the code is defined in some place which can be found using simple rules.

A [Member] can't be used if it is not explicitly imported or defined.

@source[bm]
```
import Int from bm;

let x Int = null; // OK
let y String = null; // ERROR! `String` is not defined
```

Shadowing is disallowed so references can't be ambiguous.

@source[bm]
```
let enabled = true;

class Test {
  let enabled = false; // ERROR: `enabled` is already defined
}
```

Fields must be initialized, there are no default values.

@source[bm]
```
class User {
  var id Int; // ERROR! `id` needs to be initialized
}
```


=== Readability

The written code must be easy to read and the developer must write the minimum amount of code.

The type inference allows to omit the type in most cases.

@source[bm]
```
let count = 0;                           // type: Int
let name = "Mat";                        // type: String
let rect = Rectangle.new(0, 0, 10, 10);  // type: Rectangle
let a = null;                            // type: Any
```

Parenthesis after an `if`, `for`, `while`, etc. are no required.

@source[bm]
```
function main(args Array<String>) {
  if args.length == 0 {
    println("Missing arguments");
  }
}
```

All [Members] in the most basic form share the same syntax pattern.
Advanced usage introduces specific syntax.

@source[cbnf]
```
member = [access-modifier]
  member-type
  member-name
  parameters
  [advanced-usage]
  body;
```

Extensions allow to have large class definitions and even so have small files.

@source[bm]
```
module entities {
  class User {
    let id Int;
    constructor new(@id Int) {
      id = @id;
    }
  }
}
```
< user.bm

@source[bm]
```
module entities {
  function User.delete() {
    // ...
  }
}
```
< user.delete.bm

@source[bm]
```
import entities.User;

function main() {
  // since the extension is declared in the same module
  // it is applied automatically
  User.new(10).delete();
}
```
< main.bm


=== Immutability over mutability

Parameters in functions are constant by default.

@source[bm]
```
function add(a Int, b Int) {
  a += b;                    // ERROR: `a` is constant
  return a;
}
```

Getters, setters and interfaces allow to control if a field is mutable or not.

@source[bm]
```
interface Person {
  let name String;
}
class Dog {
  var name = "Mathison";
}
function test() {
  let dog = Dog();
  dog.name = "Mat";
  let per = (Person)dog;
  per.name = "...";        // ERROR: `per.name` is constant
}
```

Declaring constants are as simple as declaring variables.

@source[bm]
```
var mutable = "";
let immutable = "";
mutable = null;
immutable = null;     // ERROR: `immutable` is constant
```

Constants can be defined in constructors easing its use.

@source[bm]
```
class Cat {
  let name; // OK: initialization is delegated
  constructor new(@name) {
    name = @name;
  }
}
```

=== Loose Coupling

[Interfaces] and [Templates] help to write code completely decoupled.

@source[bm]
```
module entities {
  class User {
    var key String = null;
  }
}
module storage {
  interface Item<ID> {
    let key ID;
  }
  class Container<ID> {
    function save(item Item<ID>) { /* do something with `item.key` */ }
  }
}
function main() {
  let container = Container<String>();
  let user = User();
  container.save(user);
}
```
< Modules `entities` and `storage` are completely decoupled.

Extensions make possible to add features to existing [Classes] and [Interfaces] without changing the original definition.

@source[bm]
```
module lib {
  share interface List<T> {
    let length Int;
    operator `[]` (index Int) T;
  }
  share module ext {
    function List.compact() List<T> {
      // create a new list without `null` values
    }
  }
}
module app {
  import List, ext from lib;
  function test() {
    let items List<Int> = [10, null, 20];

    // `compact` function comes from the extension
    log(items.compact()); // [10, 20]
  }
}
```
< The class `List` knows nothing about the function `compact`.

Multiple Inheritance allows to reduce the depth of inheritance and having decoupled classes.

@source[bm]
```
class Element {
  var id String = null;
}
class Listenable {
  protect let listeners = ArrayList<Listener>.new();
  function on(key String, handle Handler) { /* ... */ }
  function trigger(key String, event Event) { /* ... */ }
}
class Input inherits Element, Listenable {
  protect var $value String = null;
  setter value(@value String) {
    $value = @value;
    trigger("changed", Event.fromId(id));
  }
}
```
< The classes `Element` and `Listenable` are stand-alone while `Input` uses them.
