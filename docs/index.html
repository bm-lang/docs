<!DOCTYPE html>
<html>
  <head>
    <meta author="generator" content="Sergio Pedraza">
    <meta name="generator" content="STX 0.0.1">
    <title>
      Bm Language
    </title>
    <link rel="stylesheet" href="assets/styles/bm.css">
    <link rel="stylesheet" href="assets/styles/bm-hljs.css">
  </head>
  <body>
    <nav class="toc">
      <ol>
        <li>
          <a href="&#35;3472d4bda5ee58af07144130bfe252cb">1. Bm Language</a>
          <ol>
            <li>
              <a href="&#35;3b878279a04dc47d60932cb294d96259">1.1. Overview</a>
            </li>
            <li>
              <a href="&#35;d96870a2167c8e557765bc04d6a4050c">1.2. Principles</a>
              <ol>
                <li>
                  <a href="&#35;2b24f8fa79689efc18489c8876d9f85b">1.2.1. Trackable Origin</a>
                </li>
                <li>
                  <a href="&#35;032b76cfb331080ea4aea635cec00b5e">1.2.2. Readability</a>
                </li>
                <li>
                  <a href="&#35;b74f2d180489e25c0a1af38d605d2627">1.2.3. Immutability over mutability</a>
                </li>
                <li>
                  <a href="&#35;857defc5b4c6f1fef867a03c300bdd29">1.2.4. Loose Coupling</a>
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          <a href="&#35;4994a8ffeba4ac3140beb89e8d41f174">2. Language</a>
          <ol>
            <li>
              <a href="&#35;dc4c71563b9bc39a65be853457e6b7b6">2.1. Structure</a>
              <ol>
                <li>
                  <a href="&#35;ef53538ae41a651c7f72ab6cb1135d8c">2.1.1. Members</a>
                </li>
                <li>
                  <a href="&#35;5382aaf8b3d2fdeb6717f9805b0dd511">2.1.2. Containers</a>
                </li>
              </ol>
            </li>
            <li>
              <a href="&#35;82f3752789424e6fde8efcf2936868fc">2.2. Suites</a>
              <ol>
                <li>
                  <a href="&#35;74017fd89a418ebeaf603648e5bb4ddc">2.2.1. Suite File</a>
                  <ol>
                    <li>
                      <a href="&#35;49a12294a798bafdc4f71c8dd3f740e3">Suite Version</a>
                    </li>
                  </ol>
                </li>
                <li>
                  <a href="&#35;cc127fe9ca3a172620c04bbbd0336d78">2.2.2. Entry Point</a>
                </li>
              </ol>
            </li>
            <li>
              <a href="&#35;b9f0fc86133dfbe37ec5cd3a2b9d9f82">2.3. Reference System</a>
              <ol>
                <li>
                  <a href="&#35;c486251b99d5ba732f63b53c855254c4">2.3.1. Naming Rules</a>
                </li>
                <li>
                  <a href="&#35;37ff5e317e113171c88387ef4c1a1ba3">2.3.2. Member Path</a>
                </li>
                <li>
                  <a href="&#35;c30d974d91633a8d0bd7c0dc812c6a28">2.3.3. Shadowing Disallowance</a>
                </li>
              </ol>
            </li>
            <li>
              <a href="&#35;82d667afa965f349a65d256bb9799ad4">2.4. Access System</a>
              <ol>
                <li>
                  <a href="&#35;ac1e7ffd7202965a9d1c3bb0da2daf27">2.4.1. Protect Modifier</a>
                </li>
                <li>
                  <a href="&#35;79286aa5cb4ef8a1caa4126b35506da7">2.4.2. Default Modifier</a>
                </li>
                <li>
                  <a href="&#35;a3089851a526c5268af8b7790cbabe8e">2.4.3. Share Modifier</a>
                </li>
                <li>
                  <a href="&#35;5644ddaa8a642f4450425d2073b401f6">2.4.4. Export Modifier</a>
                </li>
              </ol>
            </li>
            <li>
              <a href="&#35;bf17ac149e2e7a530c677e9bd51d3fd2">2.5. Modules</a>
              <ol>
                <li>
                  <a href="&#35;a6d215054e4f9ee1123b26ba620a4073">2.5.1. Global Module</a>
                </li>
                <li>
                  <a href="&#35;d0534c6a537676c6d4f4e76ad81a2925">2.5.2. Explicit Modules</a>
                </li>
                <li>
                  <a href="&#35;e09afee87681f3d8d92002510e949891">2.5.3. Implicit Modules</a>
                </li>
              </ol>
            </li>
            <li>
              <a href="&#35;dc658425ca28537848b686dd0c3f6cde">2.6. Imports</a>
              <ol>
                <li>
                  <a href="&#35;26233f991a3997d87f360162add41ea6">2.6.1. Member Links</a>
                </li>
                <li>
                  <a href="&#35;b1435a96acf6b44fd320d4f524d59583">2.6.2. Import Syntax</a>
                </li>
                <li>
                  <a href="&#35;3769b2303dfd5ce0b572c31eacb02ef1">2.6.3. Importing Modules</a>
                </li>
              </ol>
            </li>
            <li>
              <a href="&#35;5e2f5f3c24ae8c6ab3eca618826b0e23">2.7. Extensions</a>
            </li>
            <li>
              <a href="&#35;7df96b18c230f90ada0a9e2307226338">2.8. Templates</a>
            </li>
            <li>
              <a href="&#35;6359ec70bb7b7cd12afa3db3ffe38d08">2.9. Overloading</a>
            </li>
            <li>
              <a href="&#35;3b129ca780c3ece07dd3d83fa86f934d">2.10. Extended Functions</a>
            </li>
            <li>
              <a href="&#35;61bcd96a2c1f8026527cbf2019d6e9a4">2.11. Initialization</a>
              <ol>
                <li>
                  <a href="&#35;677fba658ea6123852dbeb5450c6af85">2.11.1. Inline Initialization</a>
                </li>
                <li>
                  <a href="&#35;322fea64b110d0e8bdea1109186cf926">2.11.2. Delegated Initialization</a>
                </li>
                <li>
                  <a href="&#35;a7045aadcb20e060f0757138e1e1995f">2.11.3. Function Parameter Initialization</a>
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          <a href="&#35;1b4381923945de718be6169156e7cdc5">3. Type System</a>
          <ol>
            <li>
              <a href="&#35;d95867deadfe690e40f42068d6b59df8">3.1. References</a>
            </li>
            <li>
              <a href="&#35;f6549d3de50e5c03832fb7d139389918">3.2. Null Values</a>
            </li>
            <li>
              <a href="&#35;4189c45e4cce8e87038c5a57c899d3fc">3.3. Type Inference</a>
            </li>
            <li>
              <a href="&#35;479c01e471347f335628cee17db0bf54">3.4. Type Casting</a>
            </li>
            <li>
              <a href="&#35;ba13dd77b32ef46502e92dcef208cead">3.5. Natives</a>
            </li>
            <li>
              <a href="&#35;3fd42a7d900484fcebe0592c1dd12a94">3.6. Built-in Types</a>
            </li>
            <li>
              <a href="&#35;3f891a2ac811a9de29464304e94c8216">3.7. Literals</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="&#35;e9878b4854d29907146149f695cb1cfb">4. Classes</a>
          <ol>
            <li>
              <a href="&#35;392d134e7ce9c6913ff6a2ca7aedb8d4">4.1. Class inheritance</a>
            </li>
            <li>
              <a href="&#35;275289a0cbc920b402c5ab73a1baa3e3">4.2. Class Extension</a>
            </li>
            <li>
              <a href="&#35;a80a53718255250f108edaaa72030cb7">4.3. Interface implementation</a>
            </li>
            <li>
              <a href="&#35;5fa5b4afe4f318c3af99215de2b8c289">4.4. Incomplete Class</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="&#35;756640f0aea5f5bea1cbe250a9d08989">5. Interfaces</a>
        </li>
        <li>
          <a href="&#35;1de9b506efb3a401ba92ba35ced1574c">6. Lambdas</a>
          <ol>
            <li>
              <a href="&#35;d5e204f2c32af5d27ecbe848c767c73c">6.1. Lambda Creation</a>
              <ol>
                <li>
                  <a href="&#35;1b84b0672a371d37b14803de5f6d72af">6.1.1. Inline Lambdas</a>
                </li>
                <li>
                  <a href="&#35;0a4015fc8bae98232a58d0b71fb53741">6.1.2. Function Lambdas</a>
                </li>
                <li>
                  <a href="&#35;cca88d62e4b0eb9cf77f5d7854434736">6.1.3. Property Lambdas</a>
                </li>
                <li>
                  <a href="&#35;fcfde7e46b7b3dd8be1708f4f3d8a55d">6.1.4. Field Lambdas</a>
                </li>
                <li>
                  <a href="&#35;a594ed6eddd98ec9f39b587fd787d0c8">6.1.5. Operator Lambdas</a>
                </li>
              </ol>
            </li>
            <li>
              <a href="&#35;f2d630c9f5476e26be78c865bb09939a">6.2. Closures</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="&#35;1b22e7dc709b52f1767fe1eb5dc56625">7. Enums</a>
        </li>
        <li>
          <a href="&#35;a4ca5edd20d0b5d502ebece575681f58">8. Fields</a>
        </li>
        <li>
          <a href="&#35;e93acb146e114b5dfa6ce2d12dcb96e4">9. Functions</a>
          <ol>
            <li>
              <a href="&#35;baedcc4b537302867f0c45d22681d0d2">9.1. Function Parameters</a>
            </li>
            <li>
              <a href="&#35;e3beee990a3abfcc54a09f5727e1ee11">9.2. Optional parameters</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="&#35;9fc2d28c05ed9eb1d75ba4465abf15a9">10. Properties</a>
        </li>
        <li>
          <a href="&#35;559a25fdb98a7d1fd1c3771ac568d5e9">11. Constructors</a>
        </li>
        <li>
          <a href="&#35;b3c5827f54218753bb2c3338236446c2">12. Operators</a>
          <ol>
            <li>
              <a href="&#35;c53e00a4d3bb84a01e475949414e6942">12.1. Operator Symbols</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="&#35;49cc8e6220245b65cd7d20fc6ccc74f5">13. Instructions</a>
          <ol>
            <li>
              <a href="&#35;30ee410700ad532704814aaf5a54ebdc">13.1. Conditionals</a>
              <ol>
                <li>
                  <a href="&#35;e5c2b088a7b1c9aba82bcb70456b9da5">13.1.1. If-Else</a>
                </li>
                <li>
                  <a href="&#35;bbc155fb2b111bf61c4f5ff892915e6b">13.1.2. Switch</a>
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          <a href="&#35;4b2257cb98694284507e77f34e73c2d8">14. Loops</a>
          <ol>
            <li>
              <a href="&#35;34fc7bf2566fda38afafc173862597d9">14.1. Infinite (loop)</a>
            </li>
            <li>
              <a href="&#35;b34aaf308062646437e26d930362b703">14.2. Conditional (while)</a>
            </li>
            <li>
              <a href="&#35;be0c661d58b014ecd514eb302e39c849">14.3. Incremental (for - while - step)</a>
            </li>
            <li>
              <a href="&#35;6b5381c72456ba65152be25e0e995aa6">14.4. Iterative (for - in - else)</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="&#35;ef43236673ca0bb606b14091061ac271">15. Error Handling</a>
        </li>
        <li>
          <a href="&#35;d3c7279c25a23f98e777a7bebe35d002">16. Expressions</a>
          <ol>
            <li>
              <a href="&#35;792bda809c20cf64c9f135478527d65c">16.1. Literals</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="&#35;bb063f8e62b31e1d52eb57ff77ceb9b0">17. Auto-Closing</a>
        </li>
        <li>
          <a href="&#35;e57b90675c017905ea37fda571e74cba">18. Named Arguments</a>
        </li>
      </ol>
    </nav>
    <main>
      <h1 id="3472d4bda5ee58af07144130bfe252cb">
        1. Bm Language
      </h1>
      <p>
        By Sergio Pedraza <a href="&#35;40aa84546dd2db5926f67de6ff162789">&#64;sergiouph</a>
      </p>
      <p>
        Bm is a general purpose programming language designed to be simple to write, read and maintain.
        It can be considered a multi-paradigm language since it is focused to provide robust solutions
        by enforcing principles not limited to a specific paradigm.
      </p>
      <h2 id="3b878279a04dc47d60932cb294d96259">
        1.1. Overview
      </h2>
      <p>
        TODO
      </p>
      <h2 id="d96870a2167c8e557765bc04d6a4050c">
        1.2. Principles
      </h2>
      <p>
        The design of the Bm Language is driven by a set of principles explained below.
      </p>
      <h3 id="2b24f8fa79689efc18489c8876d9f85b">
        1.2.1. Trackable Origin
      </h3>
      <p>
        Every symbol in the code is defined in some place which can be found using simple rules.
      </p>
      <p>
        A <a href="&#35;858ba4765e53c712ef672a9570474b1d">Member</a> can&#39;t be used if it is not explicitly imported or defined.
      </p>
      <pre class="bm">import Int from bm&#59;

let x Int &#61; null&#59; // OK
let y String &#61; null&#59; // ERROR&#33; &#96;String&#96; is not defined</pre>
      <p>
        Shadowing is disallowed so references can&#39;t be ambiguous.
      </p>
      <pre class="bm">let enabled &#61; true&#59;

class Test &#123;
  let enabled &#61; false&#59; // ERROR&#58; &#96;enabled&#96; is already defined
&#125;</pre>
      <p>
        Fields must be initialized, there are no default values.
      </p>
      <pre class="bm">class User &#123;
  var id Int&#59; // ERROR&#33; &#96;id&#96; needs to be initialized
&#125;</pre>
      <h3 id="032b76cfb331080ea4aea635cec00b5e">
        1.2.2. Readability
      </h3>
      <p>
        The written code must be easy to read and the developer must write the minimum amount of code.
      </p>
      <p>
        The type inference allows to omit the type in most cases.
      </p>
      <pre class="bm">let count &#61; 0&#59;                           // type&#58; Int
let name &#61; &#34;Mat&#34;&#59;                        // type&#58; String
let rect &#61; Rectangle.new(0, 0, 10, 10)&#59;  // type&#58; Rectangle
let a &#61; null&#59;                            // type&#58; Any</pre>
      <p>
        Parenthesis after an <code>if</code>, <code>for</code>, <code>while</code>, etc. are no required.
      </p>
      <pre class="bm">function main(args Array&#60;String&#62;) &#123;
  if args.length &#61;&#61; 0 &#123;
    println(&#34;Missing arguments&#34;)&#59;
  &#125;
&#125;</pre>
      <p>
        All <a href="&#35;ef53538ae41a651c7f72ab6cb1135d8c">Members</a> in the most basic form share the same syntax pattern.
        Advanced usage introduces specific syntax.
      </p>
      <pre class="cbnf">member &#61; [access-modifier]
  member-type
  member-name
  parameters
  [advanced-usage]
  body&#59;</pre>
      <p>
        Extensions allow to have large class definitions and even so have small files.
      </p>
      <figure>
        <pre class="bm">module entities &#123;
  class User &#123;
    let id Int&#59;
    constructor new(&#64;id Int) &#123;
      id &#61; &#64;id&#59;
    &#125;
  &#125;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 1.</span> user.bm
        </figcaption>
      </figure>
      <figure>
        <pre class="bm">module entities &#123;
  function User.delete() &#123;
    // ...
  &#125;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 2.</span> user.delete.bm
        </figcaption>
      </figure>
      <figure>
        <pre class="bm">import entities.User&#59;

function main() &#123;
  // since the extension is declared in the same module
  // it is applied automatically
  User.new(10).delete()&#59;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 3.</span> main.bm
        </figcaption>
      </figure>
      <h3 id="b74f2d180489e25c0a1af38d605d2627">
        1.2.3. Immutability over mutability
      </h3>
      <p>
        Parameters in functions are constant by default.
      </p>
      <pre class="bm">function add(a Int, b Int) &#123;
  a &#43;&#61; b&#59;                    // ERROR&#58; &#96;a&#96; is constant
  return a&#59;
&#125;</pre>
      <p>
        Getters, setters and interfaces allow to control if a field is mutable or not.
      </p>
      <pre class="bm">interface Person &#123;
  let name String&#59;
&#125;
class Dog &#123;
  var name &#61; &#34;Mathison&#34;&#59;
&#125;
function test() &#123;
  let dog &#61; Dog()&#59;
  dog.name &#61; &#34;Mat&#34;&#59;
  let per &#61; (Person)dog&#59;
  per.name &#61; &#34;...&#34;&#59;        // ERROR&#58; &#96;per.name&#96; is constant
&#125;</pre>
      <p>
        Declaring constants are as simple as declaring variables.
      </p>
      <pre class="bm">var mutable &#61; &#34;&#34;&#59;
let immutable &#61; &#34;&#34;&#59;
mutable &#61; null&#59;
immutable &#61; null&#59;     // ERROR&#58; &#96;immutable&#96; is constant</pre>
      <p>
        Constants can be defined in constructors easing its use.
      </p>
      <pre class="bm">class Cat &#123;
  let name&#59; // OK&#58; initialization is delegated
  constructor new(&#64;name) &#123;
    name &#61; &#64;name&#59;
  &#125;
&#125;</pre>
      <h3 id="857defc5b4c6f1fef867a03c300bdd29">
        1.2.4. Loose Coupling
      </h3>
      <p>
        <a href="&#35;756640f0aea5f5bea1cbe250a9d08989">Interfaces</a> and <a href="&#35;7df96b18c230f90ada0a9e2307226338">Templates</a> help to write code completely decoupled.
      </p>
      <figure>
        <pre class="bm">module entities &#123;
  class User &#123;
    var key String &#61; null&#59;
  &#125;
&#125;
module storage &#123;
  interface Item&#60;ID&#62; &#123;
    let key ID&#59;
  &#125;
  class Container&#60;ID&#62; &#123;
    function save(item Item&#60;ID&#62;) &#123; /&#42; do something with &#96;item.key&#96; &#42;/ &#125;
  &#125;
&#125;
function main() &#123;
  let container &#61; Container&#60;String&#62;()&#59;
  let user &#61; User()&#59;
  container.save(user)&#59;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 4.</span> Modules <code>entities</code> and <code>storage</code> are completely decoupled.
        </figcaption>
      </figure>
      <p>
        Extensions make possible to add features to existing <a href="&#35;e9878b4854d29907146149f695cb1cfb">Classes</a> and <a href="&#35;756640f0aea5f5bea1cbe250a9d08989">Interfaces</a> without changing the original definition.
      </p>
      <figure>
        <pre class="bm">module lib &#123;
  share interface List&#60;T&#62; &#123;
    let length Int&#59;
    operator &#96;[]&#96; (index Int) T&#59;
  &#125;
  share module ext &#123;
    function List.compact() List&#60;T&#62; &#123;
      // create a new list without &#96;null&#96; values
    &#125;
  &#125;
&#125;
module app &#123;
  import List, ext from lib&#59;
  function test() &#123;
    let items List&#60;Int&#62; &#61; [10, null, 20]&#59;

    // &#96;compact&#96; function comes from the extension
    log(items.compact())&#59; // [10, 20]
  &#125;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 5.</span> The class <code>List</code> knows nothing about the function <code>compact</code>.
        </figcaption>
      </figure>
      <p>
        Multiple Inheritance allows to reduce the depth of inheritance and having decoupled classes.
      </p>
      <figure>
        <pre class="bm">class Element &#123;
  var id String &#61; null&#59;
&#125;
class Listenable &#123;
  protect let listeners &#61; ArrayList&#60;Listener&#62;.new()&#59;
  function on(key String, handle Handler) &#123; /&#42; ... &#42;/ &#125;
  function trigger(key String, event Event) &#123; /&#42; ... &#42;/ &#125;
&#125;
class Input inherits Element, Listenable &#123;
  protect var &#36;value String &#61; null&#59;
  setter value(&#64;value String) &#123;
    &#36;value &#61; &#64;value&#59;
    trigger(&#34;changed&#34;, Event.fromId(id))&#59;
  &#125;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 6.</span> The classes <code>Element</code> and <code>Listenable</code> are stand-alone while <code>Input</code> uses them.
        </figcaption>
      </figure>
      <h1 id="4994a8ffeba4ac3140beb89e8d41f174">
        2. Language
      </h1>
      <p>
        Bm can be considered as a part of the C-family languages and influenced indeed by many other languages.
        Driven by the <a href="&#35;032b76cfb331080ea4aea635cec00b5e">Readability</a> principle, the syntax of Bm is aims to be free of ambiguities for the parser
        as well for the human who reads it.
      </p>
      <p>
        The code written in Bm is free-form, there is no pattern to follow regarding the source files,
        even so, the resulting code organization keeps being relatively simple
        since the language doesn&#39;t allow to create intricated designs&#58;
      </p>
      <ul>
        <li>
          <a href="&#35;bf17ac149e2e7a530c677e9bd51d3fd2">Modules</a> are the only members which can be recursively nested.
        </li>
        <li>
          <a href="&#35;e09afee87681f3d8d92002510e949891">Implicit Modules</a> make explicit the module structure.
        </li>
        <li>
          There is no concept of <em>Inner Classes</em> or <em>Static Members</em>.
        </li>
      </ul>
      <h2 id="dc4c71563b9bc39a65be853457e6b7b6">
        2.1. Structure
      </h2>
      <p>
        Bm has a simple structure to organize the logic&#58; Members and Containers.
        Some containers are also members and some members only contain logic.
      </p>
      <table>
        <tr>
          <th>
            Item
          </th>
          <th>
            Is Container&#63;
          </th>
          <th>
            Is Member&#63;
          </th>
          <th>
            Only logic&#63;
          </th>
        </tr>
        <tr>
          <td>
            <a href="&#35;8a6fc4d8eaed89968cc3ce1116c3a654">Source File</a>  
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#10060;
          </td>
          <td>
            &#10060;
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;bf17ac149e2e7a530c677e9bd51d3fd2">Module</a>           
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#10060;
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;e9878b4854d29907146149f695cb1cfb">Class</a>            
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#10060;
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;756640f0aea5f5bea1cbe250a9d08989">Interface</a>     
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#10060;
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;1b22e7dc709b52f1767fe1eb5dc56625">Enum</a>               
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#10060;
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;1de9b506efb3a401ba92ba35ced1574c">Lambda</a>           
          </td>
          <td>
            &#10060;
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#10060;
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;a4ca5edd20d0b5d502ebece575681f58">Field</a>             
          </td>
          <td>
            &#10060;
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#10060;
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;dc658425ca28537848b686dd0c3f6cde">Import</a>           
          </td>
          <td>
            &#10060;
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#10060;
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;e93acb146e114b5dfa6ce2d12dcb96e4">Function</a>       
          </td>
          <td>
            &#10060;
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#9989;
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;9fc2d28c05ed9eb1d75ba4465abf15a9">Property</a>      
          </td>
          <td>
            &#10060;
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#9989;
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;b3c5827f54218753bb2c3338236446c2">Operator</a>       
          </td>
          <td>
            &#10060;
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#9989;
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;559a25fdb98a7d1fd1c3771ac568d5e9">Constructor</a> 
          </td>
          <td>
            &#10060;
          </td>
          <td>
            &#9989;
          </td>
          <td>
            &#9989;
          </td>
        </tr>
      </table>
      <h3 id="ef53538ae41a651c7f72ab6cb1135d8c">
        2.1.1. Members
      </h3>
      <p>
        A member represents an unique named item that belongs to a container,
        however, some members can be composed by more than one definition&#58;
      </p>
      <ul>
        <li>
          <a href="&#35;e93acb146e114b5dfa6ce2d12dcb96e4">Functions</a>, <a href="&#35;559a25fdb98a7d1fd1c3771ac568d5e9">Constructors</a> and <a href="&#35;b3c5827f54218753bb2c3338236446c2">Operators</a>&#58;
        </li>
        <li>
          <a href="&#35;9fc2d28c05ed9eb1d75ba4465abf15a9">Properties</a>&#58; a <code>getter</code> or <code>setter</code> definitions with the same name in a container, compose a single property.
        </li>
        <li>
          <a href="&#35;bf17ac149e2e7a530c677e9bd51d3fd2">Modules</a>&#58; all module definitions with the same <a href="&#35;37ff5e317e113171c88387ef4c1a1ba3">Member Path</a> found in a suite, compose the same module.
        </li>
      </ul>
      <p>
        since the <a href="&#35;6359ec70bb7b7cd12afa3db3ffe38d08">Overloading</a> of a member is allowed, each overload counts as one definition that composes the same member.
      </p>
      <h3 id="5382aaf8b3d2fdeb6717f9805b0dd511">
        2.1.2. Containers
      </h3>
      <p>
        The containers are used to group members, all members have an owner which must be a container
        (the <a href="&#35;a6d215054e4f9ee1123b26ba620a4073">Global Module</a> is the only member that doesn&#39;t have owner since it is the root).
      </p>
      <p>
        The owner of a member is not necessarily the container where it was defined&#58;
      </p>
      <ul>
        <li>
          The <a href="&#35;ba03e0554fa2fce38a1cd348547d379c"><strong>Source Files</strong></a> are containers but the actual owner of the members defined inside is the
        </li>
        <li>
          When <a href="&#35;dc658425ca28537848b686dd0c3f6cde">importing</a> a member, the actual owner of the member is where is was first defined,
        </li>
      </ul>
      <p>
        <a href="&#35;e065378f413799f976bc2950965f1f30">Implicit Module</a> which represents the directory of the file.
        the owner doesn&#39;t change becase it was imported into another module.
      </p>
      <p>
        The fact that the containers can hold members already defined in other containers helps to build the <a href="&#35;b9f0fc86133dfbe37ec5cd3a2b9d9f82">Reference System</a>.
      </p>
      <table>
        <caption>
          <span class="stx-number">Table 2.</span> Relationship between containers and members which can own
        </caption>
        <tr>
          <th>
            Container
          </th>
          <th>
            Members
          </th>
        </tr>
        <tr>
          <td>
            <a href="&#35;bf17ac149e2e7a530c677e9bd51d3fd2">Module</a>
          </td>
          <td>
            <a href="&#35;e9878b4854d29907146149f695cb1cfb">Class</a>,
            <a href="&#35;756640f0aea5f5bea1cbe250a9d08989">Interface</a>,
            <a href="&#35;e93acb146e114b5dfa6ce2d12dcb96e4">Function</a>,
            <a href="&#35;a4ca5edd20d0b5d502ebece575681f58">Field</a>,
            <a href="&#35;9fc2d28c05ed9eb1d75ba4465abf15a9">Property</a>,
            <a href="&#35;1de9b506efb3a401ba92ba35ced1574c">Lambda</a>,
            <a href="&#35;1b22e7dc709b52f1767fe1eb5dc56625">Enum</a>,
            <a href="&#35;dc658425ca28537848b686dd0c3f6cde">Import</a>,
            <a href="&#35;bf17ac149e2e7a530c677e9bd51d3fd2">Module</a>
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;e9878b4854d29907146149f695cb1cfb">Class</a>
          </td>
          <td>
            <a href="&#35;a4ca5edd20d0b5d502ebece575681f58">Field</a>,
            <a href="&#35;9fc2d28c05ed9eb1d75ba4465abf15a9">Property</a>,
            <a href="&#35;e93acb146e114b5dfa6ce2d12dcb96e4">Function</a>,
            <a href="&#35;b3c5827f54218753bb2c3338236446c2">Operator</a>,
            <a href="&#35;559a25fdb98a7d1fd1c3771ac568d5e9">Constructor</a>
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;756640f0aea5f5bea1cbe250a9d08989">Interface</a>
          </td>
          <td>
            <a href="&#35;a4ca5edd20d0b5d502ebece575681f58">Field</a>,
            <a href="&#35;e93acb146e114b5dfa6ce2d12dcb96e4">Function</a>,
            <a href="&#35;b3c5827f54218753bb2c3338236446c2">Operator</a>
          </td>
        </tr>
        <tr>
          <td>
            <a href="&#35;1b22e7dc709b52f1767fe1eb5dc56625">Enum</a>
          </td>
          <td>
            <a href="&#35;a4ca5edd20d0b5d502ebece575681f58">Field</a>
          </td>
        </tr>
      </table>
      <h2 id="82f3752789424e6fde8efcf2936868fc">
        2.2. Suites
      </h2>
      <p>
        Suites are distributable containers for all members that define an Application or a Library.
        The concepts of Application and Library are only important if the suite is expected to be executed.
        Only suites that contain an <a href="&#35;cc127fe9ca3a172620c04bbbd0336d78">Entry Point</a> can be executed and called <em>Applications</em>
        otherwise they can be considered only <em>Libraries</em>.
        At the end, all suites can be dependencies of other suites.
      </p>
      <p>
        The suites can be stored in two formats&#58;
      </p>
      <ul>
        <li>
          <strong>Source suite</strong>&#58; Is a directory with a <a href="&#35;74017fd89a418ebeaf603648e5bb4ddc">Suite File</a> that contains the source files that can be compiled.
        </li>
        <li>
          <strong>Compiled suite</strong>&#58; Is a <code>.bms</code> file that can be distributed, it contains the necessary information to be imported in other suites or executed in any plattform.
        </li>
      </ul>
      <h3 id="74017fd89a418ebeaf603648e5bb4ddc">
        2.2.1. Suite File
      </h3>
      <p>
        A suite file defines a source suite, the parent directory of the file is considered the <a href="&#35;a6d215054e4f9ee1123b26ba620a4073">Global Module</a>.
        The file should be named <code>bm.json</code> (JSON format) or <code>bm.yml</code> (YAML format).
        The following meta-data can be defined in the suite file&#58;
      </p>
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            Type
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            <code>id</code>
          </td>
          <td>
            String
          </td>
          <td>
            It is an UUID identifying the suite, it analogous to a fingerprint. This value should never be changed.
          </td>
        </tr>
        <tr>
          <td>
            <code>name</code>
          </td>
          <td>
            String
          </td>
          <td>
            The code name of the suite following the <a href="&#35;c486251b99d5ba732f63b53c855254c4">Naming Rules</a>.
          </td>
        </tr>
        <tr>
          <td>
            <code>version</code>
          </td>
          <td>
            String
          </td>
          <td>
            See <a href="&#35;49a12294a798bafdc4f71c8dd3f740e3">Suite Version</a>.
          </td>
        </tr>
        <tr>
          <td>
            <code>dependencies</code>
          </td>
          <td>
            Object
          </td>
          <td>
            Each attribute represents a dependency of the suite.
          </td>
        </tr>
      </table>
      <h4 id="49a12294a798bafdc4f71c8dd3f740e3">
        Suite Version
      </h4>
      <p>
        The suite version is a value composed by three numbers in the following format&#58; <em>major.minor.patch</em>.
        The numbers between a versions should be incremented by following these criteria&#58;
      </p>
      <ul>
        <li>
          <em>Major</em> changes break backward-compatibility.
        </li>
        <li>
          <em>Minor</em> changes introduce new features.
        </li>
        <li>
          <em>Patch</em> changes solve bugs.
        </li>
      </ul>
      <h3 id="cc127fe9ca3a172620c04bbbd0336d78">
        2.2.2. Entry Point
      </h3>
      <p>
        Since the all logic of the programs is contained in a member,
        the default entry point of a program is the function <code>main</code> that must be located in the <a href="&#35;a6d215054e4f9ee1123b26ba620a4073">Global Module</a>.
        In order to access to the arguments,
        the function may declare an array of strings (<code>Array&#60;String&#62;</code>) as the only argument.
      </p>
      <figure>
        <pre class="bm">import Array, String from bm&#59;

function main(args Array&#60;String&#62;) &#123;
  // program logic
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 7.</span> main.bm
        </figcaption>
      </figure>
      <h2 id="b9f0fc86133dfbe37ec5cd3a2b9d9f82">
        2.3. Reference System
      </h2>
      <p>
        This system defines the rules for referencing members in the code
        based on the relationship between containers and members.
        Referencing a member doesn&#39;t guarantees the access to it,
        the access to the members is managed by the <a href="&#35;82d667afa965f349a65d256bb9799ad4">Access System</a>.
      </p>
      <p>
        Since all members have a <a href="&#35;b068931cc450442b63f5b3d276ea4297">name</a>, containers can be viewed as a list of names and each name
        could contain more names since some members are containers too.
        This structure of names is delimited by following rules&#58;
      </p>
      <ul>
        <li>
          A member cannot be defined in a container if the container or any of its parents have already a member with the same name,
          this results in <a href="&#35;c30d974d91633a8d0bd7c0dc812c6a28">Shadowing Disallowance</a>.
        </li>
        <li>
          In a given container, any name defined in the container or any of its parents is available to be referenced.
        </li>
        <li>
          A member can be referenced by using the <a href="&#35;37ff5e317e113171c88387ef4c1a1ba3">Member Path</a> as long as the first name of the path is available to be referenced.
        </li>
        <li>
          The names defined in a container without name like <a href="&#35;ba03e0554fa2fce38a1cd348547d379c">Source Files</a>, are assumed by its parent container.
        </li>
        <li>
          Given two containers with name that are siblings, the members defined in each container are not available to be referenced in each other.
        </li>
      </ul>
      <h3 id="c486251b99d5ba732f63b53c855254c4">
        2.3.1. Naming Rules
      </h3>
      <p>
        Any name can be given to a member, but the way to represent the names in the Bm Language obbey two formats&#58;
      </p>
      <ul>
        <li>
          One letter followed by more letters or digits.
        </li>
        <li>
          Delimited string using grave accent (<code>&#96;</code>).
        </li>
      </ul>
      <p>
        The characters that are considered letters are
        from <code>a</code> to <code>z</code> (lowercase), from <code>A</code> to <code>Z</code> (uppercase), <code>&#95;</code> (underscore), <code>&#36;</code> (dollar sign) and <code>&#64;</code> (at symbol).
        The delimited string follows the <a href="&#35;987230585a725d5ca0bbc46e8f003c22">Character Escaping</a> rules.
      </p>
      <p>
        TODO Add information for operators.
      </p>
      <h3 id="37ff5e317e113171c88387ef4c1a1ba3">
        2.3.2. Member Path
      </h3>
      <p>
        Since the name of a member is unique, members can be referenced unambiguously using the member path
        which can be generated by joining the path of the container and the name of the member with a point (<code>.</code>),
        containers without name are ignored.
      </p>
      <figure>
        <pre class="bm">                                        // Member Path&#58;
module math &#123;                           // &#34;math&#34;
  let PI &#61; 3.141592&#59;                    // &#34;math.PI&#34;
  function max(a int, b int) int &#123;      // &#34;math.max&#34;
    return a &#62; b &#63; a &#58; b&#59;
  &#125;
  module geo &#123;                          // &#34;math.geo&#34;
    function tan(value double) double &#123; // &#34;math.geo.tan&#34;
      // fancy maths...
    &#125;
  &#125;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 8.</span> Member Path example
        </figcaption>
      </figure>
      <h3 id="c30d974d91633a8d0bd7c0dc812c6a28">
        2.3.3. Shadowing Disallowance
      </h3>
      <p>
        Naming a member with the same name than a member that can be referenced is not allowed because it generates ambiguity.
      </p>
      <pre class="bm">let x &#61; 0&#59;

class Point &#123;
  var x &#61; 0&#59; // ERROR&#58; The member &#34;x&#34; is already defined in the parent module.
  var y &#61; 0&#59;

  function moveTo(&#64;x, y) &#123; // ERROR&#58; The member &#34;y&#34; is already defined in the class &#34;Point&#34;.
    let Point &#61; null&#59; // ERROR&#58; The member &#34;Point&#34; is already defined in the parent module.
  &#125;
&#125;</pre>
      <h2 id="82d667afa965f349a65d256bb9799ad4">
        2.4. Access System
      </h2>
      <p>
        This system refers to how the members are accessed through the modules.
        This is controlled by using a set of keywords called access modifiers
        which define the rules to access to some member from a certain module.
      </p>
      <table>
        <caption>
          <span class="stx-number">Table 4.</span> How access modifiers work
        </caption>
        <tr>
          <th>
            Who can access to the member&#63; 
          </th>
          <th>
            <code>protect</code> 
          </th>
          <th>
            <em>(default)</em> 
          </th>
          <th>
            <code>share</code> 
          </th>
          <th>
            <code>export</code> 
          </th>
        </tr>
        <tr>
          <td>
            Same declaring container          
          </td>
          <td>
            &#9989; 
          </td>
          <td>
            &#9989; 
          </td>
          <td>
            &#9989; 
          </td>
          <td>
            &#9989;
          </td>
        </tr>
        <tr>
          <td>
            Same module in the same suite     
          </td>
          <td>
            &#10060; 
          </td>
          <td>
            &#9989; 
          </td>
          <td>
            &#9989; 
          </td>
          <td>
            &#9989;
          </td>
        </tr>
        <tr>
          <td>
            Any module in the same suite      
          </td>
          <td>
            &#10060; 
          </td>
          <td>
            &#10060; 
          </td>
          <td>
            &#9989; 
          </td>
          <td>
            &#9989;
          </td>
        </tr>
        <tr>
          <td>
            Any module in any suite           
          </td>
          <td>
            &#10060; 
          </td>
          <td>
            &#10060; 
          </td>
          <td>
            &#10060; 
          </td>
          <td>
            &#9989;
          </td>
        </tr>
      </table>
      <h3 id="ac1e7ffd7202965a9d1c3bb0da2daf27">
        2.4.1. Protect Modifier
      </h3>
      <p>
        The <code>protect</code> modifier is the most secure modifier, the access to members declared with this modifier
        is limited only to the container where the member was declared,
        they can&#39;t be imported or accessed by other source files.
      </p>
      <figure>
        <pre class="bm">class Foo &#123;
  protect let BAR &#61; 1&#59;
&#125;

protect let BAZ &#61; Foo().BAR &#43; 1&#59; // ERROR&#58; &#96;BAR&#96; is not accessible</pre>
        <figcaption>
          <span class="stx-number">Figure 9.</span> file1.bm
        </figcaption>
      </figure>
      <figure>
        <pre class="bm">protect let QUX &#61; BAZ &#43; 1&#59; // ERROR&#58; &#96;BAZ&#96; is not accessible

module abc &#123;
  let XYZ &#61; QUX &#43; 1&#59; // OK&#33; &#96;QUX&#96; is accessible
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 10.</span> file2.bm
        </figcaption>
      </figure>
      <h3 id="79286aa5cb4ef8a1caa4126b35506da7">
        2.4.2. Default Modifier
      </h3>
      <p>
        The <em>default</em> modifier is the most handy modifier,
        to declare a member with this kind of access the member shouldn&#39;t have an access modifier at all.
      </p>
      <p>
        This modifier makes that the member can be accessed only by
        the members defined in the same module or submodules of the same suite,
        other modules can&#39;t import or referencing the member.
        It keeps being secure, in the sense that it encapsulates the member in the declaring module.
      </p>
      <figure>
        <pre class="bm">let FOO &#61; 1&#59;</pre>
        <figcaption>
          <span class="stx-number">Figure 11.</span> file1.bm
        </figcaption>
      </figure>
      <figure>
        <pre class="bm">module bar &#123;
  let BAZ &#61; FOO &#43; 1&#59; // OK&#33; &#96;FOO&#96; is accessible
&#125;
let QUX &#61; bar.BAZ &#43; 1&#59; // ERROR&#58; &#96;BAZ&#96; is not accessible</pre>
        <figcaption>
          <span class="stx-number">Figure 12.</span> file2.bm
        </figcaption>
      </figure>
      <h3 id="a3089851a526c5268af8b7790cbabe8e">
        2.4.3. Share Modifier
      </h3>
      <p>
        The <code>share</code> modifier has two behaviours depending on the member&#58;
      </p>
      <ul>
        <li>
          Class members&#58; allows the member to be available in any subclass no matter the suite.
        </li>
        <li>
          Other members&#58; allows the importing and referencing of the member across the suite.
        </li>
      </ul>
      <figure>
        <pre class="bm">module debug &#123;
  share function log(message String) &#123; /&#42; ... &#42;/ &#125;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 13.</span> file1.bm
        </figcaption>
      </figure>
      <figure>
        <pre class="bm">module foo &#123;
  import debug.log&#59;

  function bar() &#123;
    log(&#34;bar...&#34;)&#59; // OK&#33; &#96;log&#96; is accessible
  &#125;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 14.</span> file2.bm
        </figcaption>
      </figure>
      <h3 id="5644ddaa8a642f4450425d2073b401f6">
        2.4.4. Export Modifier
      </h3>
      <p>
        The <code>export</code> modifier should only be used when the member needs to be exported outside the suite.
        Members declared in the same module or submodules have access to the declared member without importing it
        and the member can be imported in any module of any suite.
      </p>
      <figure>
        <pre class="bm">export function foo() &#123; /&#42; ... &#42;/ &#125;

share function bar() &#123; /&#42; ... &#42;/ &#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 15.</span> Suite 1 (foobar)
        </figcaption>
      </figure>
      <figure>
        <pre class="bm">import foobar.foo&#59; // OK&#33; &#96;foo&#96; is exported
import foobar.bar&#59; // ERROR&#33; &#96;bar&#96; is not exported</pre>
        <figcaption>
          <span class="stx-number">Figure 16.</span> Suite 2 (barqux)
        </figcaption>
      </figure>
      <h2 id="bf17ac149e2e7a530c677e9bd51d3fd2">
        2.5. Modules
      </h2>
      <p>
        A module is a <a href="&#35;5f0b6ebc4bea10285ba2b8a6ce78b863">container</a> for <a href="&#35;a4ca5edd20d0b5d502ebece575681f58">Fields</a>, <a href="&#35;e93acb146e114b5dfa6ce2d12dcb96e4">Functions</a>, <a href="&#35;e9878b4854d29907146149f695cb1cfb">Classes</a>,
        <a href="&#35;9fc2d28c05ed9eb1d75ba4465abf15a9">Properties</a>, <a href="&#35;1b22e7dc709b52f1767fe1eb5dc56625">Enums</a>, <a href="&#35;756640f0aea5f5bea1cbe250a9d08989">Interfaces</a>, <a href="&#35;5e2f5f3c24ae8c6ab3eca618826b0e23">Extensions</a> and more <a href="&#35;bf17ac149e2e7a530c677e9bd51d3fd2">Modules</a>.
        The access to the members is determined by its <a href="&#35;dd19d8459439eae05ba9a4c47077419f">Module Access</a>
        and they are always available during the runtime.
      </p>
      <h3 id="a6d215054e4f9ee1123b26ba620a4073">
        2.5.1. Global Module
      </h3>
      <p>
        The global module cannot be referenced inside of the suite,
        however, when using another suite as dependency,
        the global module of the other suite can be referenced by the name of the suite.
      </p>
      <figure>
        <pre class="bm">// the member is declared in the global module of the &#34;foobar&#34; suite
export function doSomething() &#123; /&#42; ... &#42;/ &#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 17.</span> Library Suite &#34;foobar&#34;
        </figcaption>
      </figure>
      <figure>
        <pre class="bm">// the global module of the library &#34;foobar&#34; is now &#34;foobar&#34;
import foobar.doSomething&#59;

export function main() &#123;
  doSomething()&#59;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 18.</span> Application Suite (depends on &#34;foobar&#34;)
        </figcaption>
      </figure>
      <h3 id="d0534c6a537676c6d4f4e76ad81a2925">
        2.5.2. Explicit Modules
      </h3>
      <p>
        The explicit modules are created by using the keyword <code>module</code>.
      </p>
      <pre class="bm">module math &#123;
  // ...
&#125;</pre>
      <h3 id="e09afee87681f3d8d92002510e949891">
        2.5.3. Implicit Modules
      </h3>
      <p>
        Modules are defined at file system level by using directories.
        The root directory is considered the global module and all other modules are relative to it.
        The source files contained in a module define the corresponding members.
      </p>
      <pre class="plain">/some/path/
&#124;- awesome-app/              &#58; Global module (root directory)
&#124;  &#124;- math/                  &#58; Module &#39;math&#39;
&#124;  &#124;  &#124;- physics/            &#58; Module &#39;math.physics&#39;
&#124;  &#124;  &#124;  &#124;- mechanics.bm
&#124;  &#124;  &#124;  &#124;- fluids.bm
&#124;  &#124;  &#92;- geometry/           &#58; Module &#39;math.geometry&#39;
&#124;  &#124;     &#124;- topology.bm
&#124;  &#124;     &#124;- trigonometry.bm
&#124;  &#124;- data/                  &#58; Module &#39;data&#39;
&#124;  &#124;  &#92;- local-storage.bm
&#124;  &#92;- main.bm</pre>
      <h2 id="dc658425ca28537848b686dd0c3f6cde">
        2.6. Imports
      </h2>
      <p>
        Shared and exported members can be imported into another module.
        The imported members become also members of the module which is importing them.
        To avoid adding complexity, the imported members cannot be renamed.
        The module access rules applies as well as any other definition,
        this means that the <code>import</code> statements can be declared with a module access modifier&#58;
      </p>
      <ul>
        <li>
          <p>
            <strong>Protected imports</strong>&#58; are useful when it is required to use a member from another module or suite
            that it is not going to be widely used, so in order to use it, it must be imported in every container where is required.
          </p>
          <pre class="bm">protect import math.max&#59; // this member will only be used here

export function validatePort(port Int) Bool &#123;
  return max(port, 0)&#59;
&#125;</pre>
        </li>
        <li>
          <p>
            <strong>Default imports</strong>&#58; are useful to create the environment of the module by importing members that will be used in the module
            and submodules.
          </p>
          <pre class="bm">// following members will be widely used across the module
import assert, log, inspect from debug&#59;</pre>
        </li>
        <li>
          <p>
            <strong>Shared imports</strong>&#58; are useful for composing a module or avoiding name collisions.
          </p>
          <pre class="bm">module impl &#123;
  // need to be shared to expose them outside this module
  share import somelibrary.log&#59;
  share import otherlibrary.timestamp&#59;
&#125;

function log(message String) &#123;
  impl.log(&#34;&#36;&#123;impl.timestamp()&#125; - &#36;&#123;message&#125;&#34;)&#59;
&#125;</pre>
        </li>
        <li>
          <p>
            <strong>Exported imports</strong>&#58; are useful to re-distribute a member.
          </p>
          <pre class="bm">// need to be exported so &#96;getTypeName&#96; can be exported as well
export import constants.Type&#59;

export function getTypeName(type Type) String &#123; /&#42; ... &#42;/ &#125;</pre>
        </li>
      </ul>
      <h3 id="26233f991a3997d87f360162add41ea6">
        2.6.1. Member Links
      </h3>
      <p>
        When importing a member it is just linked so no clones of the member are generated.
        At the end the real module owner of the member is where the member was defined, not where it was imported.
        This implies that the access rules depend on the real module, not the importing one.
      </p>
      <pre class="bm">module AAA &#123;
  share class Foo &#123; let BAR &#61; 1&#59; &#125;
&#125;

module BBB &#123; share import AAA.Foo&#59; &#125;

module CCC &#123;
  function test() &#123;
    log(AAA.Foo.BAR)&#59; // ERROR let Foo.BAR is not shared
    log(BBB.Foo.BAR)&#59; // ERROR let Foo.BAR is not shared
  &#125;
&#125;

// Notice the module is the same than the owner of Foo
module AAA &#123;
  function test() &#123;
    log(Foo.BAR)&#59; // exactly the same than the line below
    log(AAA.Foo.BAR)&#59; // OK&#33; it has access
    log(BBB.Foo.BAR)&#59; // OK&#33; it has access
  &#125;
&#125;</pre>
      <h3 id="b1435a96acf6b44fd320d4f524d59583">
        2.6.2. Import Syntax
      </h3>
      <p>
        Multiple members can be imported using the same sentence, if the module is indicated all imported members
        must be of the same module.
      </p>
      <pre class="bm">module A &#123;
  share module B &#123;
    share let X &#61; 1&#59;
    share let Y &#61; 2&#59;
    share let Z &#61; 3&#59;
  &#125;
  share module C &#123;
    share let I &#61; 1&#59;
    share let J &#61; 2&#59;
    share let K &#61; 3&#59;
  &#125;
&#125;

module example1 &#123;
  import A.B.X, A.B.Y, A.B.Z,
         A.C.I, A.C.J, A.C.K&#59;
&#125;

module example2 &#123;
  import B.X, B.Y, B.Z
         C.I, C.J, C.K from A&#59;
&#125;

module example3 &#123;
  import X, Y, Z from A.B&#59;
  import I, J, L from A.C&#59;
&#125;

module example4 &#123;
  import A.B, A.C&#59;
&#125;</pre>
      <h3 id="3769b2303dfd5ce0b572c31eacb02ef1">
        2.6.3. Importing Modules
      </h3>
      <p>
        When a module is imported, all members of the module becomes members of the importing module.
      </p>
      <h2 id="5e2f5f3c24ae8c6ab3eca618826b0e23">
        2.7. Extensions
      </h2>
      <p>
        Extensions allow to add members to existing types without modifying the existing definition or creating a new type.
        The way to define extensions is by prefixing the member name with the type reference followed by two colons (<code>&#58;&#58;</code>),
        only members with logic can be used as extensions&#58;
      </p>
      <ul>
        <li>
          <a href="&#35;e93acb146e114b5dfa6ce2d12dcb96e4">Functions</a>
        </li>
        <li>
          <a href="&#35;9fc2d28c05ed9eb1d75ba4465abf15a9">Properties</a>
        </li>
        <li>
          <a href="&#35;559a25fdb98a7d1fd1c3771ac568d5e9">Constructors</a>
        </li>
        <li>
          <a href="&#35;b3c5827f54218753bb2c3338236446c2">Operators</a>
        </li>
      </ul>
      <p>
        The body of the extension member, just like Class Members, has access to <code>this</code> representing the instance
        and all other intance members will be available.
      </p>
      <pre class="bm">class User &#123;
  var name String &#61; null&#59;
&#125;

function User&#58;&#58;delete() &#123;
  Console.log(&#34;Deleting user &#36;&#123;name&#125;&#34;)&#59; // OK&#33; &#96;name&#96; is available
&#125;</pre>
      <p>
        When an extension is defined in the same module and suite than the extended type,
        the extension member will be treated as a member of the type,
        so when the type is imported it will have the extension members available.
      </p>
      <pre class="bm">module lib &#123;
  share class Collection &#123; /&#42; ... &#42;/ &#125;

  share function Collection&#58;&#58;clean() &#123; /&#42; ... &#42;/ &#125;
&#125;
module app &#123;
  import Collection from lib&#59;

  function test() &#123;
    Collection().clean()&#59; // OK&#33; &#96;clean&#96; is available
  &#125;
&#125;</pre>
      <p>
        If the extension member is declared in a different module than the extended type,
        it needs to be imported explicitly so the type can have the extension member available.
      </p>
      <pre class="bm">module lib &#123;
  share class Collection &#123; /&#42; ... &#42;/ &#125;

  module actions &#123;
    share function Collection&#58;&#58;clean() &#123; /&#42; ... &#42;/ &#125;
  &#125;
&#125;
module app &#123;
  import Collection from lib&#59;
  import User&#58;&#58;clean from actions.lib&#59; // this line is required for the extension
  function test() &#123;
    Collection().clean()&#59; // OK&#33; &#96;clean&#96; is available
    clean()&#59; // ERROR&#58; &#96;clean&#96; is not defined
  &#125;
&#125;</pre>
      <h2 id="7df96b18c230f90ada0a9e2307226338">
        2.8. Templates
      </h2>
      <p>
        Generic programming is implemented by adding a template signature to
        <a href="&#35;e9878b4854d29907146149f695cb1cfb">Classes</a>, <a href="&#35;756640f0aea5f5bea1cbe250a9d08989">Interfaces</a>, <a href="&#35;1de9b506efb3a401ba92ba35ced1574c">Lambdas</a>, <a href="&#35;e93acb146e114b5dfa6ce2d12dcb96e4">Functions</a> and <a href="&#35;b3c5827f54218753bb2c3338236446c2">Operators</a>.
        The template signature can define one or more Template Types associated with another type,
        when the associated type is not specified it is assumed to be <code>Any</code>.
        Template Types are considered valid types in the inner implementation.
      </p>
      <p>
        Template Members can only be used if the Template Arguments are clear, it can happen in two ways&#58;
      </p>
      <ul>
        <li>
          Explicit Template Arguments&#58; Types that have a Template Signature must be referenced by using this mode which includes
          <a href="&#35;e9878b4854d29907146149f695cb1cfb">Classes</a>, <a href="&#35;756640f0aea5f5bea1cbe250a9d08989">Interfaces</a> and <a href="&#35;1de9b506efb3a401ba92ba35ced1574c">Lambdas</a>.
        </li>
        <li>
          Inferred Template Arguments&#58; <a href="&#35;e93acb146e114b5dfa6ce2d12dcb96e4">Functions</a> and <a href="&#35;b3c5827f54218753bb2c3338236446c2">Operators</a> are referenced without arguments.
        </li>
      </ul>
      <pre class="bm">interface Comparable&#60;T&#62; &#123;
  operator &#96;&#61;&#61;&#96; (value&#33; T) Bool&#59;
&#125;

interface Entity&#60;ID&#62; &#123;
  var id Comparable&#60;ID&#62;&#59;
&#125;

class User &#123;
  var id Int&#59;
&#125;

class Container&#60;ID&#62; &#123;
  function store(entity Entity&#60;ID&#62;) &#123; /&#42; ... &#42;/ &#125;
&#125;

lambda Storer&#60;T&#62;(item T)&#59;

function createStorer&#60;ID&#62;() Storer&#60;ID&#62; &#123;
  let container &#61; Container&#60;ID&#62;()&#59;

  return container.store&#59;
&#125;

function main() &#123;
  let store Storer&#60;Int&#62;  // Explicit Template Arguments
    &#61; createStorer()&#59;    // Inferred Template Arguments
  let user &#61; User()&#59;

  store(user)&#59;
&#125;</pre>
      <h2 id="6359ec70bb7b7cd12afa3db3ffe38d08">
        2.9. Overloading
      </h2>
      <p>
        Members that accepts parameters can be overloaded, this means that
        more than one definition can be provided with the same name as long as
        the parameters at the same position are not compatibles with each other.
        There is no restriction on the number of parameters or if they are optional.
      </p>
      <figure>
        <pre class="bm">function print(value Any) &#123; /&#42; ... &#42;/ &#125;
function print(value String) &#123; /&#42; ... &#42;/ &#125;
// ERROR&#33; &#96;String&#96; is compatible with &#96;Any&#96;.</pre>
        <figcaption>
          <span class="stx-number">Figure 19.</span> Invalid Overloads
        </figcaption>
      </figure>
      <figure>
        <pre class="bm">function max(a Int, b, Int) Int &#123; /&#42; ... &#42;/ &#125;
function max(a Single, b Single) Single &#123; /&#42; ... &#42;/ &#125;
// OK&#33; &#96;Int&#96; and &#96;Single&#96; are not compatibles</pre>
        <figcaption>
          <span class="stx-number">Figure 20.</span> Valid Overloads
        </figcaption>
      </figure>
      <h2 id="3b129ca780c3ece07dd3d83fa86f934d">
        2.10. Extended Functions
      </h2>
      <p>
        Overriding inherited functions in classes is disallowed, however the way of adding behaviour is by using <code>before</code> and <code>after</code>.
      </p>
      <p>
        Since in Bm is not possible to override an inherited function, an alternative might be to add aspects to the class
        so it can be possible to execute some block of code before or after the function is called.
      </p>
      <p>
        Aspects should be directly added only to inherited functions to avoid obscuring the logic of normal functions.
      </p>
      <p>
        The block of code to be executed before or after the function should not have return type,
        the parameters for <em>before</em> blocks, should be exactly the same than the target function and
        the parameters for <em>after</em> blocks, should be the same than the target function plus the return type only when it applies.
        In this way, aspects will be able to mutate the input and output of a function, but won&#39;t be able to change the references.
      </p>
      <p>
        Only one aspect per <em>before</em> and <em>after</em> should be allowed in one class.
        The aspects added to functions which the superclasses already added aspects will be chained.
      </p>
      <pre class="bm">class Shape &#123;
  var x &#61; 0&#59;
  var y &#61; 0&#59;

  function moveTo(&#64;x Int, &#64;y Int) &#123;
    x &#61; &#64;x&#59;
    y &#61; &#64;y&#59;
  &#125;
&#125;

class Element &#123;
  function redraw() &#123; /&#42; ... &#42;/ &#125;
&#125;

class Oval inherits Element, Shape &#123;

  after moveTo(&#64;x Int, &#64;y Int) &#123;
    redraw()&#59;
  &#125;

  var width &#61; 0&#59;
  var height &#61; 0&#59;

  function draw(g Graphics) &#123;
    g.drawOval(x, y, width, height)&#59;
  &#125;

&#125;</pre>
      <h2 id="61bcd96a2c1f8026527cbf2019d6e9a4">
        2.11. Initialization
      </h2>
      <p>
        All fields must be initialized explicitly by the developer, there is no concept of implicit default value like <code>0</code>, <code>false</code> or <code>null</code>.
        A field can be only initialized by using one of the three ways described below.
      </p>
      <h3 id="677fba658ea6123852dbeb5450c6af85">
        2.11.1. Inline Initialization
      </h3>
      <p>
        This is the simpler way, the value is specified immediately after the declaration.
      </p>
      <pre class="bm">var count &#61; 0&#59;
let user &#61; User.new(&#34;Mat&#34;)&#59;</pre>
      <h3 id="322fea64b110d0e8bdea1109186cf926">
        2.11.2. Delegated Initialization
      </h3>
      <p>
        The initialization of the fields in a class can be delegated to the constructors.
      </p>
      <p>
        The initial value for the field can be omited in the field&#39;s declaration,
        but the class must declare one or more constructors
        and each constructor must initialize the field.
      </p>
      <pre class="bm">class Entity &#123;
  let id String&#59; // initialization delegated

  constructor new(&#64;id String) &#123;
    id &#61; &#64;id&#59; // initial value
  &#125;
&#125;</pre>
      <p>
        NOTE&#58; See <a href="&#35;559a25fdb98a7d1fd1c3771ac568d5e9">Constructors</a> for more details.
      </p>
      <h3 id="a7045aadcb20e060f0757138e1e1995f">
        2.11.3. Function Parameter Initialization
      </h3>
      <p>
        Despite a function parameter can be considered as a field, the initialization is optional since
        the initial value is taken from the function invocation.
      </p>
      <p>
        However, initial values in function parameters are allowed but it indicates an <a href="&#35;c2f948b8f1dd878029a86c91baffbb05">Optional Parameter</a>.
      </p>
      <pre class="bm">function test(a String, b String &#61; &#34;bar&#34;) &#123;
  // do something
&#125;

function main() &#123;
  // the initial values will be&#58;
  // a &#61; &#34;foo&#34; and b &#61; &#34;bar&#34;
  test(&#34;foo&#34;)&#59;
&#125;</pre>
      <p>
        NOTE&#58; See <a href="&#35;baedcc4b537302867f0c45d22681d0d2">Function Parameters</a> for more details.
      </p>
      <h1 id="1b4381923945de718be6169156e7cdc5">
        3. Type System
      </h1>
      <p>
        Bm is a language statically typed, all values are resolved to a type at compiling time.
        The usage of iterfaces and templates makes possible to write code for abstract types,
        however, at compiling time the type abstractions are resolved to well-defined types.
      </p>
      <p>
        Following list shows the types that can be declared&#58;
      </p>
      <ul>
        <li>
          Class&#58; Values can have, fields, properties, functions and operators. Can only be created by using constructors.
        </li>
        <li>
          Enum&#58; Only a limited set of values that inherits from a class can exist.
        </li>
        <li>
          Interface&#58; Describes how a value should look like. Cannot be created, but if some value matches the definition, it can be assigned.
        </li>
        <li>
          Lambda&#58; Describes how a function should look like. Cannot be created, but if some function matches the definition, is can be assigned.
        </li>
        <li>
          Template&#58; Allows an advanced use of interfaces to compose complex types.
        </li>
      </ul>
      <h2 id="d95867deadfe690e40f42068d6b59df8">
        3.1. References
      </h2>
      <p>
        In Bm all values are passed by reference, this means that if a value is passed to a function,
        the function is able to modify the received value without creating a copy.
      </p>
      <p>
        There is no way to indicate that the value should be passed by value instead of reference (creating a copy),
        however, the compiler, depending on the platform, can decide how to pass the value based on the mutability of the value.
      </p>
      <h2 id="f6549d3de50e5c03832fb7d139389918">
        3.2. Null Values
      </h2>
      <p>
        In Bm all references can be null by default no matter the type of the field,
        the only way to avoid null values in a field is declaring it with the non-null modifier (<code>&#33;</code>) after the name.
        When a field has a null value, it means that the field doesn&#39;t have a valid value.
        If a field is declared as non-null, it is guaranteed to never hold a null value.
        Null value assignments to non-null fields will throw an error at runtime,
        compilation errors only happen if the assignment can be detected by the compiler.
      </p>
      <h2 id="4189c45e4cce8e87038c5a57c899d3fc">
        3.3. Type Inference
      </h2>
      <p>
        All values&#39; types can be inferred at compiling time, but in some cases the type has to be declared explicitly
        to avoid generalities or specificity. The most generic value that can be assumed is <code>Any</code> and
        the most specific will depend on the initial value.
      </p>
      <pre class="bm">// if the type is not specified it would be Any
var name String &#61; null&#59;

// if the type is not specified it would be bool
var value Any &#61; true&#59;</pre>
      <h2 id="479c01e471347f335628cee17db0bf54">
        3.4. Type Casting
      </h2>
      <p>
        Type casting makes possible to treat a value as if it was of other type without creating another value.
        Syntax&#58;
      </p>
      <pre class="bm">(TargetType)sourceValue</pre>
      <p>
        When the type of the source value and the target type are not compatible an error is generated.
      </p>
      <p>
        TODO&#58; Complete adding examples and indicating if it is generated at compiling time, runtime or both.
      </p>
      <h2 id="ba13dd77b32ef46502e92dcef208cead">
        3.5. Natives
      </h2>
      <p>
        TODO Explain that can be implemented by the compiler, list expected natives, explain how to pass values from bm.json to runtime.
      </p>
      <h2 id="3fd42a7d900484fcebe0592c1dd12a94">
        3.6. Built-in Types
      </h2>
      <p>
        Bm is not oriented to a specific platform or hardware, however, in order to operate it defines a set of native classes
        which are assumed to exist and can be used to create more complex types.
      </p>
      <table>
        <caption>
          <span class="stx-number">Table 5.</span> Built-in Classes
        </caption>
        <tr>
          <th>
            Type
          </th>
          <th>
            Size
          </th>
          <th>
            Description
          </th>
          <th>
            Range
          </th>
        </tr>
        <tr>
          <td>
            Byte
          </td>
          <td>
            8 bits
          </td>
          <td>
            Smallest signed integer.
          </td>
          <td>
            &#8722;128 to &#43;127
          </td>
        </tr>
        <tr>
          <td>
            UByte
          </td>
          <td>
            8 bits
          </td>
          <td>
            Smallest unsigned integer.
          </td>
          <td>
            0 to 255
          </td>
        </tr>
        <tr>
          <td>
            Short
          </td>
          <td>
            16 bits
          </td>
          <td>
            Medium-sized signed integer.
          </td>
          <td>
            &#8722;32,768 to &#43;32,767
          </td>
        </tr>
        <tr>
          <td>
            UShort
          </td>
          <td>
            16 bits
          </td>
          <td>
            Medium-sized unsigned integer.
          </td>
          <td>
            0 to 65,535
          </td>
        </tr>
        <tr>
          <td>
            Int
          </td>
          <td>
            32 bits
          </td>
          <td>
            Default signed integer.
          </td>
          <td>
            &#8722;2,147,483,648 to &#43;2,147,483,647
          </td>
        </tr>
        <tr>
          <td>
            UInt
          </td>
          <td>
            32 bits
          </td>
          <td>
            Default unsigned integer.
          </td>
          <td>
            0 to 4,294,967,295
          </td>
        </tr>
        <tr>
          <td>
            Long
          </td>
          <td>
            64 bits
          </td>
          <td>
            Biggest signed integer.
          </td>
          <td>
            &#8722;9,223,372,036,854,775,808 to &#43;9,223,372,036,854,775,807
          </td>
        </tr>
        <tr>
          <td>
            ULong
          </td>
          <td>
            64 bits
          </td>
          <td>
            Biggest unsigned integer.
          </td>
          <td>
            0 to 18,446,744,073,709,551,615
          </td>
        </tr>
        <tr>
          <td>
            Single
          </td>
          <td>
            32 bits
          </td>
          <td>
            Single-precision floating-point number
          </td>
          <td>
          </td>
        </tr>
        <tr>
          <td>
            Double
          </td>
          <td>
            64 bits
          </td>
          <td>
            Double-precision floating-point number
          </td>
          <td>
          </td>
        </tr>
        <tr>
          <td>
            Bool
          </td>
          <td>
            8 bits
          </td>
          <td>
            <code>true</code> or <code>false</code>
          </td>
          <td>
          </td>
        </tr>
        <tr>
          <td>
            Char
          </td>
          <td>
            16 bits
          </td>
          <td>
            Any unicode character.
          </td>
          <td>
          </td>
        </tr>
        <tr>
          <td>
            String
          </td>
          <td>
            Depends on the instance.
          </td>
          <td>
            Stores a sequence of Chars.
          </td>
          <td>
          </td>
        </tr>
        <tr>
          <td>
            Array&#60;T&#62;
          </td>
          <td>
            Depends on the instance.
          </td>
          <td>
            Stores a sequence of values of the same type.
          </td>
          <td>
          </td>
        </tr>
      </table>
      <p>
        As well as specific classes are expected to exist, some interfaces are necessary to provide complete and decoupled
        support of some features of the language.
      </p>
      <table>
        <caption>
          <span class="stx-number">Table 6.</span> Built-in Interfaces
        </caption>
        <tr>
          <th>
            Type
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            Any
          </td>
          <td>
            Represents any value.
          </td>
        </tr>
        <tr>
          <td>
            Tuple&#60;...&#62;
          </td>
          <td>
            Stores a sequence of values of specific types per item.
          </td>
        </tr>
        <tr>
          <td>
            Error
          </td>
          <td>
            Describes an error at runtime.
          </td>
        </tr>
      </table>
      <h2 id="3f891a2ac811a9de29464304e94c8216">
        3.7. Literals
      </h2>
      <p>
        Numbers&#58;
      </p>
      <pre class="bm">function main() &#123;
  let way1 &#61; (Byte)127&#59;
  let way2 Byte &#61; 127&#59;
  let way3 &#61; (n Byte) &#61;&#62; &#123;&#125;&#59;

  way3(127)&#59;
&#125;</pre>
      <h1 id="e9878b4854d29907146149f695cb1cfb">
        4. Classes
      </h1>
      <p>
        Classes are custom types that can be instantiated into values using constructors.
        All other members declared in the class than the construtors can only be accessed through an instance of the class.
        Only some <a href="&#35;890a5232ba6f611161c6a045c96a9323">Built-in Classes</a> can be created using literals, without invoking a constructor.
      </p>
      <figure>
        <pre class="bm">class User &#123;
  let id Int&#59;
  var name String &#61; null&#59;
  var email String &#61; null&#59;

  constructor new(&#64;id) &#123; id &#61; &#64;id&#59; &#125;

  function delete() &#123; /&#42; ... &#42;/ &#125;

  getter displayName String &#123; return &#34;&#36;&#123;name&#125; &#60;&#36;&#123;email&#125;&#62;&#34;&#59; &#125;

  operator &#61;&#61; (other&#33; User) Bool &#123; return this.id &#61;&#61; other.id&#59; &#125;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 21.</span> Class Implementation
        </figcaption>
      </figure>
      <figure>
        <pre class="bm">class User &#123;
  let id Int&#59;
  var name String &#61; null&#59;
  var email String &#61; null&#59;

  constructor new(&#64;id) &#123; id &#61; &#64;id&#59; &#125;
&#125;

function User&#95;delete(user User) &#123; /&#42; ... &#42;/ &#125;

function User&#95;get&#95;displayName(user User) &#123; return &#34;&#36;&#123;user.name&#125; &#60;&#36;&#123;user.email&#125;&#62;&#34;&#59; &#125;

function User&#95;equals(User left, User right) &#123;
  if left &#61;&#61; null &#123; return right &#61;&#61; null&#59; &#125;
  else if right &#61;&#61; null &#123; return false&#59; &#125;
  else &#123; return left.id &#61;&#61; right.id&#59; &#125;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 22.</span> Equivalent Implementation
        </figcaption>
      </figure>
      <h2 id="392d134e7ce9c6913ff6a2ca7aedb8d4">
        4.1. Class inheritance
      </h2>
      <p>
        TODO remove multi-inheritance and allow interfaces to have defined functions (but not initialized fields)
      </p>
      <p>
        Classes can inherit from one or more classes only following these rules&#58;
      </p>
      <ul>
        <li>
          The constructors in the base class must be chained to one constructor of each superclass.
        </li>
        <li>
          A class can&#39;t define a member with a name already defined in some superclass,
          in other words, inherited members cannot be overridden.
        </li>
        <li>
          If two or more superclasses have a member with the same name it will cause an inheritance collision.
        </li>
      </ul>
      <p>
        NOTE&#58; See <a href="&#35;1b4381923945de718be6169156e7cdc5">Type System</a> for more details.
      </p>
      <pre class="bm">// represents an identifiable thing
class Entity &#123;
  export let id String&#59;

  share constructor new(&#64;id String) &#123;
    id &#61; &#64;id&#59;
  &#125;
&#125;

// represents a record with control fields
class Record &#123;
  export let createdAt Date&#59;

  share var &#36;updatedAt Date &#61; null&#59;

  share constructor new() &#123;
    createdAt &#61; Date.now()&#59;
  &#125;

  export getter updatedAt Date &#123;
    return &#36;updatedAt&#59;
  &#125;
&#125;

// represents the user entity record
class User inherits Entity, Record &#123;

  protect var &#36;name String &#61; null&#59;

  // must be chained to the superclasses&#39; constructors
  export constructor new(&#64;id String)
    &#58; Entity.new(&#64;id), Record.new() &#123;&#125;

  export getter name &#123; return &#36;name&#59; &#125;

  // non-protected superclasses&#39; members can be accessed
  export setter name(&#64;name String) &#123;
    &#36;name &#61; &#64;name&#59;
    &#36;updatedAt &#61; Date.now()&#59;
  &#125;
&#125;

function test() &#123;
  let user &#61; User.new(&#34;0001&#34;)&#59;
  console.log(user.id)&#59;          // prints 0001
  console.log(user.name)&#59;        // prints null
  console.log(user.updatedAt)&#59;   // prints null
  console.log(user.createdAt)&#59;   // prints a Date

  user.name &#61; &#34;Mat&#34;&#59;

  console.log(user.name)&#59;        // prints Mat
  console.log(user.updatedAt)&#59;   // prints a Date
&#125;</pre>
      <h2 id="275289a0cbc920b402c5ab73a1baa3e3">
        4.2. Class Extension
      </h2>
      <p>
        TODO&#58; Keyword <code>extends</code>. Only one superclass allowed. Inherits everything even the constructors.
      </p>
      <h2 id="a80a53718255250f108edaaa72030cb7">
        4.3. Interface implementation
      </h2>
      <p>
        Despite it is not necessary, a class can explicitly implement one or more <a href="&#35;ad63a35ea2ac8a42233e5ac6cb325d34">interfaces</a>.
        The compiler will verify that the class comply with the definition of the interfaces.
        The interfaces specified will obbey the <a href="&#35;dd20911ceb09d09907cd21424c0b5e65">Interface Inheritance</a> rules.
        If a function specified by an interface is not implemented, the class will be trated as <a href="&#35;5fa5b4afe4f318c3af99215de2b8c289">Incomplete Class</a>.
      </p>
      <pre class="bm">interface Drawable &#123;
  function draw(g Graphcs)&#59;
&#125;

interface Shape &#123;
  getter origin Point&#59;
  getter size Size&#59;
&#125;

class Rectangle implements Drawable, Shape &#123;
  export var origin Point &#61; null&#59;
  export var size Size &#61; null&#59;

  export function draw(g Graphics) &#123;
    g.drawRect(origin.x, origin.y, size.width, size.height)&#59;
  &#125;

  export constructor new() &#123;&#125;
&#125;

class Oval &#123;
  export var origin Point &#61; null&#59;
  export var size Size &#61; null&#59;

  export function draw(g Graphics) &#123;
    g.drawOval(origin.x, origin.y, size.width, size.height)&#59;
  &#125;

  export constructor new() &#123;&#125;
&#125;

function test() &#123;
  let g &#61; Graphics.new()&#59;
  let shapes &#61; ArrayList&#60;Shape&#62;.new()&#59;

  shapes.add(Rectangle.new())&#59;

  // next line is correct despite it was not explicit in the class definition
  shapes.add(Oval.new())&#59;

  for shapes &#58; shape &#123;
    shape.draw(g)&#59;
  &#125;
&#125;</pre>
      <h2 id="5fa5b4afe4f318c3af99215de2b8c289">
        4.4. Incomplete Class
      </h2>
      <p>
        Since classes can inherit from other classes, the complete definition can be delegated to subclasses.
        Rules&#58;
      </p>
      <ul>
        <li>
          Only functions, getters, and setters can be defined as incomplete members.
        </li>
        <li>
          Classes with incomplete members can&#39;t be instantiated since the complete definition is missing.
        </li>
        <li>
          Classes designed to be instantiated must define all incomplete members that were inherited.
        </li>
      </ul>
      <h1 id="756640f0aea5f5bea1cbe250a9d08989">
        5. Interfaces
      </h1>
      <p>
        Interfaces are descriptors of types.
        Any value can be trated as an interface without explicit casting
        as long as the type of the value matches with the definition of the interface.
      </p>
      <figure>
        <pre class="bm">interface Name inherits SuperInterface1, SuperInterface2 &#123;
  function doSomething(param1 ParamType) ReturnType&#59;
  getter someField Type&#59;
  setter someField(value Type)&#59;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 23.</span> Interface syntax example
        </figcaption>
      </figure>
      <p>
        Interfaces can only contain <a href="&#35;e93acb146e114b5dfa6ce2d12dcb96e4">Functions</a>, <a href="&#35;9fc2d28c05ed9eb1d75ba4465abf15a9">Properties</a> and <a href="&#35;b3c5827f54218753bb2c3338236446c2">Operators</a>.
      </p>
      <p>
        Interfaces can inherit from other interfaces, however if two or more superinterfaces have a member
        with the same name they must exactly match, otherwise it will cause an inheritance collision.
      </p>
      <p>
        Interfaces are resolved to classes at compiling time depending on the usage.
        The compiler will create an specific implementation per each usage.
      </p>
      <figure>
        <pre class="bm">interface Sortable &#123;
  operator &#60; (value Sortable)&#59;
&#125;

function sort(items Array&#60;Sortable&#62;) &#123; /&#42; ... &#42;/ &#125;

function main() &#123;
  let ids &#61; [10, 54, 32]&#59;      // Array&#60;Int&#62;
  let names &#61; [&#34;D&#34;, &#34;B&#34;, &#34;X&#34;]&#59; // Array&#60;String&#62;

  // in order compile, &#96;Int&#96; and &#96;String&#96;
  // must implement the &#96;&#60;&#96; operator.
  sort(ids)&#59;
  sort(names)&#59;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 24.</span> Implementation with Interfaces
        </figcaption>
      </figure>
      <figure>
        <pre class="bm">function sort&#95;Array&#95;Int(items Array&#60;Int&#62;) &#123; /&#42; ... &#42;/ &#125;
function sort&#95;Array&#95;String(items Array&#60;String&#62;) &#123; /&#42; ... &#42;/ &#125;

function main() &#123;
  let ids &#61; [10, 54, 32]&#59;
  let names &#61; [&#34;D&#34;, &#34;B&#34;, &#34;X&#34;]&#59;

  sort&#95;Array&#95;Int(ids)&#59;
  sort&#95;Array&#95;String(names)&#59;
&#125;</pre>
        <figcaption>
          <span class="stx-number">Figure 25.</span> Equivalent Implementation
        </figcaption>
      </figure>
      <h1 id="1de9b506efb3a401ba92ba35ced1574c">
        6. Lambdas
      </h1>
      <p>
        Lambdas are types that represents functions.
        When a field is declared with a lambda type, the field can be trated as a function.
        Any member that contain logic can be converted to a lambda value as long as it matches with the lambda type.
        Lambdas can also be created inline.
      </p>
      <h2 id="d5e204f2c32af5d27ecbe848c767c73c">
        6.1. Lambda Creation
      </h2>
      <p>
        There are more than one way to create a lambda&#58;
      </p>
      <h3 id="1b84b0672a371d37b14803de5f6d72af">
        6.1.1. Inline Lambdas
      </h3>
      <p>
        Inline lambdas are created inside intruction blocks,
        a <a href="&#35;580601915d6ef3900dc60cebbc7ba2b5">closure</a> is generated when fields are captured in the lambda&#58;
      </p>
      <pre class="bm">lambda Action()&#59;
lambda Logger(message String)&#59;
lambda Operation(a int, b int) int&#59;

function main() &#123;
  // receives one arguments doesn&#39;t return a result
  let log Logger &#61; (msg) -&#62; &#123; /&#42; ... &#42;/ &#125;&#59;

  // receives two arguments a returns a result
  let sum Operation &#61; (a, b) -&#62; a &#43; b&#59;
  let div Operation &#61; (num, den) -&#62; &#123;
    if den &#61;&#61; 0 &#123; throw Error.new()&#59; &#125;

    return a / b&#59;
  &#125;&#59;

  // no arguments, no result
  let test Action &#61; () -&#62; &#123;
    log(sum(1, 2))&#59; // 1 &#43; 2 &#61; 3
    log(div(3, 3))&#59; // 3 / 3 &#61; 1
  &#125;&#59;

  test()&#59;
&#125;</pre>
      <h3 id="0a4015fc8bae98232a58d0b71fb53741">
        6.1.2. Function Lambdas
      </h3>
      <p>
        Functions can be converted to lambdas as long as they match with the type.
      </p>
      <pre class="bm">lambda Writer(message String)&#59;

function print(message String) &#123; /&#42; ... &#42;/ &#125;

class Console &#123;
  function log(message String) &#123; /&#42; ... &#42;/ &#125;
&#125;

function main() &#123;
  let write1 Writer &#61; print&#59;
  let write2 Writer &#61; Console().log&#59;

  write1(&#34;test 1&#33;&#34;)&#59;
  write2(&#34;test 2&#33;&#34;)&#59;
&#125;</pre>
      <h3 id="cca88d62e4b0eb9cf77f5d7854434736">
        6.1.3. Property Lambdas
      </h3>
      <p>
        Since properties contain logic they can be converted to lambdas as well.
      </p>
      <pre class="bm">var name &#61; null&#59;

getter hasName Bool &#123;
  return name &#33;&#61; null&#59;
&#125;

setter hasName(value Bool) &#123;
  if value and name &#61;&#61; null &#123; name &#61; &#34;Default&#34;&#59; &#125;
  else not value and name &#33;&#61; null &#123; name &#61; null&#59; &#125;
&#125;

lambda Getter() Bool&#59;
lambda Setter(value Bool)&#59;

function test() &#123;
  let get Getter &#61; hasName&#59;
  let set Setter &#61; hasName&#59;

  console.log(name)&#59;  // null
  console.log(get())&#59; // false
  set(true)&#59;
  console.log(get())&#59; // true
  console.log(name)&#59;  // &#34;Default&#34;
&#125;</pre>
      <h3 id="fcfde7e46b7b3dd8be1708f4f3d8a55d">
        6.1.4. Field Lambdas
      </h3>
      <p>
        Since fields can be converted to properties, fields can be converted to lambdas in the same way than properties.
      </p>
      <pre class="bm">var version &#61; 1&#59;

lambda Getter() Int&#59;
lambda Setter(value Int)&#59;

function main() &#123;
  let getVersion Getter &#61; version&#59;
  let setVersion Setter &#61; version&#59;

  console.log(getVersion())&#59; // 1
  setVersion(2)&#59;
  console.log(getVersion())&#59; // 2
&#125;</pre>
      <h3 id="a594ed6eddd98ec9f39b587fd787d0c8">
        6.1.5. Operator Lambdas
      </h3>
      <p>
        Since operators contains logic, they can be converted to lambdas.
      </p>
      <pre class="bm">class Bag &#123;
  operator &#96;&#43;&#96; (bag&#33; Bag) Bag &#123;
    let merged &#61; Bag()&#59;
    // some magic to merge both bags here
    return merged&#59;
  &#125;
&#125;

lambda Merger(bag&#33; Bag) Bag&#59;

function main() &#123;
  let bag &#61; Bag()&#59;
  let merge Merger &#61; bag.&#96;&#43;&#96;&#59;

  // both lines are equivalent&#58;
  let r1 &#61; merge(Bag())&#59;
  let r2 &#61; bag &#43; Bag()&#59;
&#125;</pre>
      <h2 id="f2d630c9f5476e26be78c865bb09939a">
        6.2. Closures
      </h2>
      <p>
        <a href="&#35;1b84b0672a371d37b14803de5f6d72af">Inline Lambdas</a> can capture constant fields creating a closure.
      </p>
      <pre class="bm">lambda Logger(message String)&#59;

function createLogger(prefix String) Logger&#60;String&#62; &#123;
  return (message) -&#62; &#123;
    // Notice &#96;prefix&#96; is captured in this lambda.
    console.log(&#34;&#36;&#123;prefix&#125; - &#36;&#123;message&#125;&#34;)&#59;
  &#125;&#59;
&#125;

function test() &#123;
  let warn &#61; createLogger(&#34;[W]&#34;)&#59;
  let info &#61; createLogger(&#34;[I]&#34;)&#59;

  warn(&#34;Danger&#33; Danger&#33;&#34;)&#59;           // [W] - Danger&#33; Danger&#33;
  info(&#34;Don&#39;t talk to strangers.&#34;)&#59;  // [I] - Don&#39;t talk to strangers.
&#125;</pre>
      <h1 id="1b22e7dc709b52f1767fe1eb5dc56625">
        7. Enums
      </h1>
      <p>
        Enums are a custom type which can only have a limited set of existing values.
      </p>
      <p>
        Enums cannot have superclass.
        Enums cannot be initialized.
      </p>
      <pre class="bm">enum Alignment &#123;
  LEFT,
  RIGHT,
  CENTER,
  START,
  END,
&#125;

function test() &#123;
  var a Alignment &#61; null&#59;

  a &#61; Alignment.LEFT&#59;    // OK
  a &#61; Alignment(&#34;LEFT&#34;)&#59; // OK
  a &#61; Alignment(0)&#59;      // OK
&#125;</pre>
      <h1 id="a4ca5edd20d0b5d502ebece575681f58">
        8. Fields
      </h1>
      <p>
        Fields are variables or constants that have a value stored in the memory.
        All fields have a type which cannot be changed after the declaration and can be either explicitly declared or inferred through the initialization.
      </p>
      <p>
        Fields can be only owned by following members and the lifespan will depend on the owner&#58;
      </p>
      <ul>
        <li>
          <a href="&#35;bf17ac149e2e7a530c677e9bd51d3fd2">Modules</a>&#58; The field will be always living on runtime.
        </li>
        <li>
          <a href="&#35;e9878b4854d29907146149f695cb1cfb">Classes</a>&#58; The field will live as long as the class instance lives.
        </li>
        <li>
          <a href="&#35;baedcc4b537302867f0c45d22681d0d2">Function Parameters</a>&#58; The field will live during the execution of the function.
        </li>
        <li>
          <a href="&#35;9770431aa61d5d9a64c0d674fdbb666b">Instruction Blocks</a>&#58; The field will live during the execution of the block.
        </li>
      </ul>
      <pre class="bm">module math &#123;
  let PI &#61; 3.1415&#59;
&#125;

class Point &#123;
  var x &#61; 0&#59;
  var y &#61; 0&#59;
&#125;

function swap(list List&#60;Any&#62;, index1 Int, index2 Int) &#123;
  let aux &#61; list[index1]&#59;
  list[index1] &#61; list[index2]&#59;
  list[index2] &#61; aux&#59;
&#125;</pre>
      <h1 id="e93acb146e114b5dfa6ce2d12dcb96e4">
        9. Functions
      </h1>
      <p>
        Functions are invocable blocks of code which can receive arguments and optionally produce a result.
      </p>
      <p>
        Only when the function has a return type specifed, the function must use the <code>return</code> statement
        to complete the execution with a result.
      </p>
      <p>
        Functions can be only owned by following members and the way to invoke them will depend on the owner&#58;
      </p>
      <ul>
        <li>
          <a href="&#35;bf17ac149e2e7a530c677e9bd51d3fd2">Modules</a>&#58; Functions can be invoked directly.
        </li>
        <li>
          <a href="&#35;e9878b4854d29907146149f695cb1cfb">Classes</a>&#58; Functions can only invoked through an instance.
        </li>
      </ul>
      <pre class="bm">function abs(n Number) Number &#123;
  return n &#60; 0 &#63; -n &#58; n&#59;
&#125;

class Rectangle &#123;
  var width &#61; 0.0&#59;
  var height &#61; 0.0&#59;

  constructor new(&#64;width int, &#64;height int) &#123;
    width &#61; &#64;width&#59;
    height &#61; &#64;height&#59;
  &#125;

  function computeArea() float &#123;
    return width &#42; height&#59;
  &#125;
&#125;

function main() &#123;
  // module functions can be invoked directly
  console.log(abs(-1))&#59;             // output&#58; 1

  // class functions need an instance to be invoked
  let rect &#61; Rectangle.new(10, 20)&#59;
  console.log(rect.computeArea())&#59;  // output&#58; 200
&#125;</pre>
      <h2 id="baedcc4b537302867f0c45d22681d0d2">
        9.1. Function Parameters
      </h2>
      <p>
        Functions can receive any number of parameters which are considered as fields available only during the function execution.
      </p>
      <p>
        In order to improve readability, the keywords <code>var</code> and <code>let</code> are optional when declaring parameters and it is defaulted to <code>let</code>.
      </p>
      <p>
        Since parameters are passed by <a href="&#35;b8af13ea9c8fe890c9979a1fa8dbde22">reference</a>, reassignments only affects the reference in the function&#39;s body.
      </p>
      <pre class="bm">function test(name String, var index int&#33;) &#123;
  name &#61; &#34;Mat&#34;&#59;      // ERROR&#58; The field can&#39;t be reasigned
  index &#61; index &#43; 1&#59; // OK&#33; the field is explicitly &#96;var&#96;
&#125;</pre>
      <h2 id="e3beee990a3abfcc54a09f5727e1ee11">
        9.2. Optional parameters
      </h2>
      <p>
        Optional parameters are allowed by specifying the initial value when declaring them.
        Any parameter can be optional no matter the order, however, when invoking the function
        sending a list of arguments, optional parameters can&#39;t be skipped.
        The only way to skip an optional parameter is by invoking the function
        using <a href="&#35;e57b90675c017905ea37fda571e74cba">Named Arguments</a>.
      </p>
      <p>
        It doesn&#39;t matter if the optional parameter is <code>let</code> or <code>var</code>, the initial value
        specified in the parameter declaration is only used when there is no value specified
        in the function invocation.
      </p>
      <pre class="bm">function write(data List&#60;byte&#62;, offset int&#33; &#61; 0, length int &#61; null) &#123;
  // ...
&#125;

function test() &#123;
  let data &#61; [1, 2, 3]&#59;     // Optional arguments received&#58;
  write(data)&#59;              //  offset &#61; 0, length &#61; null
  write(data, 1)&#59;           //  offset &#61; 1, length &#61; null
  write(data, 1, 2)&#59;        //  offset &#61; 1, length &#61; 2
  write(data, length&#58; 2)&#59;   //  offset &#61; 0, length &#61; 2
&#125;</pre>
      <h1 id="9fc2d28c05ed9eb1d75ba4465abf15a9">
        10. Properties
      </h1>
      <p>
        Unlike normal fields, properties aren&#39;t allocated in memory, every time they are retrieved or assigned,
        the getter or setter logic is executed respectively.
      </p>
      <p>
        Despite properties are declared separately by using getters and setters, they must comply with following rules&#58;
      </p>
      <ul>
        <li>
          Properties can only be owned by <a href="&#35;bf17ac149e2e7a530c677e9bd51d3fd2">Modules</a> and <a href="&#35;e9878b4854d29907146149f695cb1cfb">Classes</a>.
        </li>
        <li>
          In a class or module, there can only be one getter and one setter with the same name in order to conform a property.
        </li>
        <li>
          Getters must return a value and can&#39;t receive any parameter.
        </li>
        <li>
          Setters must receive only one parameter and can&#39;t return values.
        </li>
        <li>
          In a property, the return type of the getter must be exactly the same than the setter parameter.
        </li>
      </ul>
      <p>
        When using interfaces, fields can be treated as properties transparently.
      </p>
      <pre class="bm">class DefaultApplication &#123;
  export let version String &#61; &#34;1.0&#34;&#59;

  protect &#36;baseTitle String &#61; &#34;Default Application&#34;&#59;

  export getter title() String &#123;
    return &#36;baseTitle &#43; &#34; v&#36;&#123;version&#125;&#34;&#59;
  &#125;

  export setter title(&#64;title String) &#123;
    &#36;baseTitle &#61; &#64;title&#59;
  &#125;
&#125;

class CustomApplication &#123;
  export var title String &#61; &#34;Custom Application&#34;&#59;

  protect let &#36;majorVersion int&#59;
  protect let &#36;minorVersion int&#59;

  export constructor new(&#64;maj int, &#64;min int) &#123;
    &#36;majorVersion &#61; &#64;maj&#59;
    &#36;minorVersion &#61; &#64;min&#59;
  &#125;

  export getter version() String &#123;
    return &#36;majorVersion &#43; &#34;.&#34; &#43; &#36;minorVersion&#59;
  &#125;
&#125;

interface Application &#123;
  let version String&#59;
  var title String&#59;
&#125;

function test() &#123;
  var app Application &#61; null&#59;

  app &#61; DefaultApplication()&#59;

  console.log(app.title)&#59;   // &#34;Default Application v1.0&#34;
  console.log(app.version)&#59; // &#34;1.0&#34;
  app.title &#61; &#34;MyApp&#34;&#59;
  console.log(app.title)&#59;   // &#34;MyApp v1.0&#34;

  app &#61; CustomApplication.new(2, 3)&#59;

  console.log(app.title)&#59;   // &#34;Custom Application&#34;
  console.log(app.version)&#59; // &#34;2.3&#34;
  app.title &#61; &#34;MyApp&#34;&#59;
  console.log(app.title)&#59;   // &#34;MyApp&#34;
&#125;</pre>
      <h1 id="559a25fdb98a7d1fd1c3771ac568d5e9">
        11. Constructors
      </h1>
      <p>
        Constructors are the only way to create an instance of a class, every class must have at least one constructor in order to be instantiable.
        Constructors can only be invoked through the class name, they don&#39;t need an instance to be invoked.
      </p>
      <p>
        When a class is inheriting from another class with already defined constructors, the constructor must be chained.
      </p>
      <p>
        A class can be designed to be only extended and prevent it to have direct instances, this can be only reached through protected constructors.
        Protected constructors can only be invoked in subclasses.
      </p>
      <p>
        Constructors are not inherited so a constructor in a subclass can have the same name of a superclass constructor.
      </p>
      <pre class="bm">class Entity &#123;
  export let id String&#59;

  protect constructor new(&#64;id String) &#123;
    id &#61; &#64;id&#59;
  &#125;
&#125;

class User inherits Entity &#123;
  export let name&#59;

  // &#96;new&#96; constructor can be declared since they are not inherited
  export constructor new(&#64;id String, &#64;name String)
    &#58; Entity.new(&#64;id) &#123; // super-constructor can be accessed only here
    name &#61; &#64;name&#59;
  &#125;
&#125;

function test() &#123;
  let entity &#61; Entity.new(&#34;0001&#34;)&#59;         // constructor is not accessible here
  let user &#61; User.new(&#34;0001&#34;, &#34;Mathison&#34;)&#59; // accessible constructor
&#125;</pre>
      <h1 id="b3c5827f54218753bb2c3338236446c2">
        12. Operators
      </h1>
      <p>
        Operators are special functions which can be overloaded.
      </p>
      <h2 id="c53e00a4d3bb84a01e475949414e6942">
        12.1. Operator Symbols
      </h2>
      <table>
        <tr>
          <th>
            Symbol 
          </th>
          <th>
            Name 
          </th>
          <th>
            Usage 
          </th>
          <th>
            Description 
          </th>
        </tr>
        <tr>
          <td>
            <code>&#61;&#61;</code>
          </td>
          <td>
            Equality
          </td>
          <td>
            <code>this &#61;&#61; other</code>
          </td>
          <td>
            Returns a <code>bool&#33;</code> indicating if <code>this</code> is equal to the <code>other</code> value. 
          </td>
        </tr>
        <tr>
          <td>
            <code>&#62;</code>
          </td>
          <td>
            Greater than
          </td>
          <td>
            <code>this &#62; other</code>
          </td>
          <td>
            Returns a <code>bool&#33;</code> indicating if <code>this</code> is greater than the <code>other</code> value. 
          </td>
        </tr>
        <tr>
          <td>
            <code>&#60;</code>
          </td>
          <td>
            Less than
          </td>
          <td>
            <code>this &#60; other</code>
          </td>
          <td>
            Returns a <code>bool&#33;</code> indicating if <code>this</code> is less than the <code>other</code> value. 
          </td>
        </tr>
        <tr>
          <td>
            <code>&#62;&#61;</code>
          </td>
          <td>
            Greater than or equal to
          </td>
          <td>
            <code>this &#62;&#61; other</code>
          </td>
          <td>
            Returns a <code>bool&#33;</code> indicating if <code>this</code> is greater than or equal to the <code>other</code> value. 
          </td>
        </tr>
        <tr>
          <td>
            <code>&#92;&#60;&#61;</code>
          </td>
          <td>
            Less than or equal to
          </td>
          <td>
            <code>this &#92;&#60;&#61; other</code>
          </td>
          <td>
            Returns a <code>bool&#33;</code> indicating if <code>this</code> is less than or equal to the <code>other</code> value. 
          </td>
        </tr>
        <tr>
          <td>
            <code>[]</code>
          </td>
          <td>
            Array access
          </td>
          <td>
            <code>result &#61; this<a href="&#35;b80bb7740288fda1f201890375a60c8f">id</a></code>
          </td>
          <td>
            Returns whatever is in the <code>id</code> position of <code>this</code>. 
          </td>
        </tr>
        <tr>
          <td>
            <code><a href="&#35;d41d8cd98f00b204e9800998ecf8427e"></a>&#61;</code>
          </td>
          <td>
            Array assignment
          </td>
          <td>
            <code>this<a href="&#35;b80bb7740288fda1f201890375a60c8f">id</a> &#61; value</code>
          </td>
          <td>
            Assigns the <code>value</code> to the <code>id</code> position of <code>this</code>. 
          </td>
        </tr>
      </table>
      <pre class="bm">class Vector &#123;
  export var x &#61; 0.0&#59;
  export var y &#61; 0.0&#59;
  export var magnitude &#61; 0.0&#59;
  export var direction &#61; 0.0&#59;

  export constructor new(&#64;x float, &#64;y float, &#64;m float, &#64;d float) &#123;
    x &#61; &#64;x&#59;
    y &#61; &#64;y&#59;
    magnitude &#61; &#64;m&#59;
    direction &#61; &#64;d&#59;
  &#125;

  export operator &#43; (other Vector) Vector &#123;
    let result &#61; Vector.new()&#59;

    // do fancy math here

    return result&#59;
  &#125;
&#125;

function test() &#123;
  let vec1 &#61; Vector.new(0, 0, 10, 0)&#59;
  let vec2 &#61; Vector.new(0, 0, 10, -180)&#59;
  let sum &#61; vec1 &#43; vec2&#59;

  Console.log(sum)&#59; // &#123; x&#58; 0, y&#58; 0, magnitude&#58; 0, direction&#58; 0 &#125;
&#125;</pre>
      <h1 id="49cc8e6220245b65cd7d20fc6ccc74f5">
        13. Instructions
      </h1>
      <h2 id="30ee410700ad532704814aaf5a54ebdc">
        13.1. Conditionals
      </h2>
      <h3 id="e5c2b088a7b1c9aba82bcb70456b9da5">
        13.1.1. If-Else
      </h3>
      <pre class="bm">if condition1 &#123;

&#125;
else if condition2 &#123;

&#125;
else &#123;

&#125;</pre>
      <h3 id="bbc155fb2b111bf61c4f5ff892915e6b">
        13.1.2. Switch
      </h3>
      <pre class="bm">switch value &#123;
  case A &#123;

  &#125;
  case B or C &#123;

  &#125;
  else &#123;

  &#125;
&#125;</pre>
      <h1 id="4b2257cb98694284507e77f34e73c2d8">
        14. Loops
      </h1>
      <h2 id="34fc7bf2566fda38afafc173862597d9">
        14.1. Infinite (loop)
      </h2>
      <pre class="bm">loop &#123;
  // do things

  if condition &#123;
    break&#59;
  &#125;
&#125;</pre>
      <h2 id="b34aaf308062646437e26d930362b703">
        14.2. Conditional (while)
      </h2>
      <pre class="bm">let stack &#61; Stack&#60;int&#62;.new([10, 20, 30])&#59;

while stack.length &#62; 0 &#123;
  let item &#61; stack.pop()&#59;
  console.log(&#34;item &#61; &#36;&#123;item&#125;&#34;)&#59;
&#125;

// Output&#58;
// item &#61; 30
// item &#61; 20
// item &#61; 10</pre>
      <h2 id="be0c661d58b014ecd514eb302e39c849">
        14.3. Incremental (for - while - step)
      </h2>
      <pre class="bm">for i &#61; 0 while i &#60; count step i&#43;&#43; &#123;
  console.log(&#34;i &#61; &#36;&#123;count&#125;&#34;)&#59;
&#125;

// Output&#58;
// i &#61; 0
// i &#61; 1
// ...
// i &#61; 9</pre>
      <h2 id="6b5381c72456ba65152be25e0e995aa6">
        14.4. Iterative (for - in - else)
      </h2>
      <pre class="bm">let list &#61; [10, 20, 30]&#59;

for item in list &#123;
  console.log(&#34;item &#61; &#36;&#123;item&#125;&#34;)&#59;
&#125;
else &#123;
  console.log(&#34;No items found&#34;)&#59;
&#125;

// Output&#58;
// item &#61; 10
// item &#61; 20
// item &#61; 30</pre>
      <h1 id="ef43236673ca0bb606b14091061ac271">
        15. Error Handling
      </h1>
      <pre class="bm">function main() &#123;
  for i &#61; 0 while i &#60; 100 step 1 &#123;
    if i &#61;&#61; 23 &#123;
      raise RuntimeError.new(&#34;I don&#39;t like 23&#34;)&#59;
    &#125;

    rescue e RuntimeError &#123;
      // I don&#39;t care
    &#125;
  &#125;
&#125;</pre>
      <h1 id="d3c7279c25a23f98e777a7bebe35d002">
        16. Expressions
      </h1>
      <p>
        TODO
      </p>
      <h2 id="792bda809c20cf64c9f135478527d65c">
        16.1. Literals
      </h2>
      <p>
        TODO
      </p>
      <h1 id="bb063f8e62b31e1d52eb57ff77ceb9b0">
        17. Auto-Closing
      </h1>
      <pre class="bm">using writer &#61; path.createWriter()&#59;
writer.write([10, 20, 30])&#59;</pre>
      <h1 id="e57b90675c017905ea37fda571e74cba">
        18. Named Arguments
      </h1>
      <pre class="bm">find(text&#58; &#34;mat&#34;, fromIndex&#58; 10)&#59;</pre>
      <!--html/scripts.html-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>

<script type="text/javascript">
  hljs.registerLanguage('bm', hljs => {
    var keywords = [
      'and',
      'as',
      'break',
      'catch',
      'class',
      'let',
      'constructor',
      'defer',
      'do',
      'else',
      'enum',
      'export',
      'extension',
      'for',
      'from',
      'function',
      'getter',
      'if',
      'implements',
      'import',
      'inherits',
      'interface',
      'lambda',
      'loop',
      'module',
      'native',
      'not',
      'of',
      'operator',
      'or',
      'protect',
      'return',
      'setter',
      'share',
      'this',
      'throw',
      'using',
      'var',
      'while',
    ];
    var literals = [
      'true', 'false', 'null',
    ];
    var built_ins = [
      // interfaces
      'Any',
      'Error',
      'List',
      'String',

      // types
      'Int',
      'Long',
      'Bool',
      'Single',
      'Double',

      // methods
      'close',
      'pull',
      'peek',

      // modules
      'Console',
    ];
    return {
      keywords: {
        keyword: keywords.join(' '),
        literal: literals.join(' '),
        built_in: built_ins.join(' '),
      },
      contains: [
        {
          className: 'comment',
          variants: [
            { begin: /\/\//, end: /$/ },
            { begin: /\/\*/, end: /\*\// }
          ]
        },
        {
          className: 'string',
          variants: [
            { begin: '\"', end: '\"' },
            { begin: '\'', end: '\'' },
            { begin: '`', end: '`' },
            { begin: '```', end: '```' },
            { begin: '\"\"\"', end: '\"\"\"' },
          ],
          contains: [
            {
              className: 'template',
              begin: /\$\{/,
              end: /\}/
            }
          ],
        },
        {
          className: 'number',
          variants: [
            { begin: '[^a-zA-Z][0-9]+' },
          ]
        },
      ]
    };
  });
</script>

<script type="text/javascript">
  hljs.registerLanguage('cbnf', hljs => {
    return {
      contains: [
        {
          className: 'string',
          variants: [
            { begin: /\"/, end: /\"/ },
          ]
        },
        {
          className: 'comment',
          variants: [
            { begin: /\#/, end: /$/ }
          ]
        },
        {
          className: 'keyword',
          begin: /[A-Za-z]+/,
          end: /[A-Za-z0-9\-]*/
        },
      ]
    };
  });
</script>

<script type="text/javascript">
  document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((block) => {
      hljs.highlightBlock(block);
    });
  });
</script>

<script type="text/javascript">
  ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(tag => {
    for (const element of document.getElementsByTagName(tag)) {
      const content = element.innerText;
      const id = element.getAttribute('id');
      if (id) {
        element.innerHTML = `<a href="#${id}">${content}</a>`;
      }
    }
  });
</script>
    </main>
  </body>
</html>
